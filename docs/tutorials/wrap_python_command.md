

# Wrap a python module and expose functionality to run within QCrBox

This guide walks you through the process of encapsulating a Python module within a QCrBox container. Specifically, we'll focus on a module that queries the [Crystallographic Open Database (COD)](https://www.crystallography.net/cod/) for structures with similar elements and unit cell parameters. Our goal is to make this module's functionality accessible within a QCrBox container.

## Prerequisites

Before starting, ensure your development environment is set up following the guide located [here](../how_to_guides/set_up_a_dev_environment.md). During this tutorial you will work with Docker, Python, and an understanding of YAML configurations. If you're new to these concepts you can just accept the additions as they are or consusult additional resources on [Docker](https://docs.docker.com/get-started/overview/), [Python modules](https://docs.python.org/3/tutorial/modules.html), and [YAML](https://yaml.org/spec/1.2/spec.html) for foundational knowledge.

## Initial Setup

To begin, initialize a new QCrBox container for our module:

1. Open your terminal.
2. Type `qcb init cod_check` and press Enter.
3. You will be prompted to provide basic information about your application through a guided dialogue. Follow the prompts to complete the setup.

```
Please provide some basic information about your application.
The following dialog will guide you through the relevant settings.

  [1/7] Select application_type
    1 - CLI
    Choose from [1] (1): 1
  [2/7] application_slug (cod_check):
  [3/7] application_name (Cod Check): COD Check
  [4/7] application_version (x.y.z): 0.0.1
  [5/7] description (Brief description of the application.): Can be used to check whether there is a similar structure in the crystallographic open database and output similar structures.
  [6/7] url (): https://my.official.module.url
  [7/7] email (): module_contact@university.somewhere

Created scaffolding for new application in 'T:\QCrBox_location\services\applications\cod_check'.
```

## Understanding the Generated Scaffolding

Navigate to the application's folder to see the files generated by the boilerplace CLI. You'll find:

- `docker-compose.cod_check.*.yml`: Docker Compose files, typically unchanged for non-GUI applications.
- `sample_cmd.sh`: An example bash file for CLI applications. This can be deleted.
- `Dockerfile`: Contains instructions to build the container.
- `config_cod_check.yaml`: Future versions will use this to define exposed functions. Currently, it requests CIF keywords.
- `configure_cod_check.py`: Here, we'll implement our module's functionality and register it with QCrBox.

Next, download the Python file [here](./example_support/simple_cod_module.py) and copy `simple_cod_module.py` into the `cod_check` folder.

## Adding the First Command to `config_cod_check.yaml`

In the first step of this tutorial, we aim to introduce a command that outputs the number of structures with matching unit cell parameters and elements, as specified in a CIF file, to a JSON file within the work folder. Refer to the `simple_cod_module.py` script to understand the functionalities we're integrating. We will use the `cif_to_search_pars` function to generate search parameters and then employ `get_number_fitting_cod_entries` to find the count of matching structures.

The initial setup, generated by `qcb init`, has already populated the top section of the YAML file. Your task now is to customize this section with our specific command details. Start by renaming `name` from the placeholder to `"get_number_fitting_cod_entries"` and change `implemented_as` from `"cli"` to `"python_callable"`.

The command will require three parameters:

  1. `input_cif_path` (string): Specifies which CIF file to use for checking similar structures.
  2. `cellpar_deviation_perc` (float): Defines the maximum allowable deviation, in percentage, for unit cell parameters between COD structures and our target structure. The default value is set at 2.0%.
  3. `listed_elements_only` (boolean): When set to True, the search will only include entries containing the exact elements listed in the `input_cif` file. If False, the search will accept entries with additional elements beyond those listed. By default, this is set to False.

Here is how you should structure the command in the YAML file:

```yaml
commands:
  - name: "get_number_fitting_cod_entries"
    implemented_as: "python_callable"
    parameters:
      - name: "input_cif_path"
        type: "str"
        default_value: None
      - name: "cellpar_deviation_perc"
        type: "float"
        default_value: 2.0
        required: false
      - name: "listed_elements_only"
        type: "bool"
        default_value: false
        required: false
```

### Specifying Required CIF Entries

Next, we must identify which CIF entries are essential for our command to function. Inspect the `cif_to_search_pars` function to determine these entries. If you're adding only one command, list these required entries directly. Ensure that `required_cif_entries:` aligns with the `parameters:` section for proper structure.

```yaml
    required_cif_entries: [
      "_cell_length_a", "_cell_length_b", "_cell_length_c",
      "_cell_angle_alpha", "_cell_angle_beta", "_cell_angle_gamma",
      "_chemical_formula_sum"
    ]
```

For scenarios where certain CIF entries are beneficial but not mandatory, you could list them under `optional_cif_entries`. However, in this context, all listed entries are necessary, completing our current modifications to the YAML file.

## Implementing the Python Glue Code

> **Important Note:**
> Currently, some functionality that will eventually be automated—specifically, the registration of our application and commands in Python, as well as CIF file handling and conversion—requires manual implementation. This step is temporary and is planned to be automated in future updates, following the developer alpha release. We're releasing this functionality now to provide a foundation for exploration and development.

To begin, open the `configure_cod_check.py` file. Start by importing necessary functions from the python base libraries as well as two different modules:

```python
from pathlib import Path
import json

from qcrboxtools.cif.cif2cif import cif_file_unified_yml_instr
from simple_cod_module import cif_to_search_pars, get_number_fitting_cod_entries
```

The function `cif_file_unified_yml_instr` is designed to manage the CIF files' input and output, converting the CIF keywords used by QCrBox into those required by `simple_cod_module`. Additionally, we'll utilize two specific functions from `simple_cod_module` to execute our desired logic.

Let's proceed to define the necessary Python functions within `configure_cod_check.py`:

```python
YAML_PATH = "./config_cod_check.yaml"

def parse_input(input_cif_path, cellpar_deviation_perc, listed_elements_only):
    # Convert string paths to Path objects for easier file handling
    input_cif_path = Path(input_cif_path)

    # Convert cellpar_deviation to the correct type and convert the given percentage to a decimal
    cellpar_deviation = float(cellpar_deviation_perc) / 100.0

    # Validate 'listed_elements_only' as a boolean value
    if listed_elements_only.lower() not in ("true", "false"):
        raise ValueError("'listed_elements_only' must be a boolean (true or false).")

    # Convert 'listed_elements_only' to a boolean
    listed_elements_only = listed_elements_only.lower() == "true"

    # Use the parent directory of the input CIF file as the working directory
    work_folder = input_cif_path.parent

    # Specify the path for the modified CIF file
    work_cif_path = work_folder / "work.cif"

    # Adjust the CIF file according to the requirements of 'simple_cod_module'
    cif_file_unified_yml_instr(
        input_cif_path=input_cif_path,
        output_cif_path=work_cif_path,
        yml_path=YAML_PATH,  # Referencing the edited YAML configuration
        command="get_number_fitting_cod_entries",  # Command name as specified in the YAML
    )
    return work_cif_path, cellpar_deviation, listed_elements_only

def qcb_get_number_fitting_cod_entries(input_cif_path, cellpar_deviation_perc, listed_elements_only):
    # Transform input parameters from string to appropriate Python objects
    work_cif_path, cellpar_deviation, listed_elements_only = parse_input(input_cif_path, cellpar_deviation_perc, listed_elements_only)

    # Retrieve the number of matching entries
    elements, cell_dict = cif_to_search_pars(work_cif_path)
    n_entries = get_number_fitting_cod_entries(elements, cell_dict, cellpar_deviation, listed_elements_only)

    # Save the output as a JSON file
    with open(work_cif_path.parent / "nentries.json", "w", encoding="UTF-8") as fobj:
        json.dump({"n_entries": n_entries}, fobj)
```

The `parse_input` function will eventually be phased out as QCrBox plans will take over the input parameter handling and CIF file conversion making the explicit implementation obsolete.

## Registering the Python Function as a QCrBox Command

To integrate our command with QCrBox, it's necessary to register it within the system. Update the script's concluding section as follows:

```python
client = QCrBoxRegistryClient()
application = client.register_application("COD Check", version="0.0.1")

# Register the command with QCrBox, linking it to our Python function
application.register_python_callable("get_number_fitting_cod_entries", qcb_get_number_fitting_cod_entries)

client.run()
```

QCrBox recognizes the parameter names from our Python function, using them directly as command parameters within the for the commands exposed by the QCrBox container.


## Configuring the Dockerfile

The Dockerfile is preconfigured with some entries that we won't need. Here's a simplified explanation and modifications required:

1. **Base Image Setup**: The file begins with specifying the base image for the application. We use the `qcrbox/base-application` as our starting point, utilizing the latest version available.
    ```Dockerfile
    ARG QCRBOX_DOCKER_TAG
    FROM qcrbox/base-application:${QCRBOX_DOCKER_TAG}
    ```

2. **Environment Setup**: Specifies using `/bin/bash` for running future commands.
    ```Dockerfile
    SHELL ["/bin/bash", "-c"]
    ```

3. **Inclusion of QCrBox settings files**: The following lines will copy the `/configure_*.py` and the `/config_*.yaml` to our container, that we have modified to integrate our program with QCrBox.

    ```Dockerfile
    COPY configure_cod_check.py ./
    COPY config_cod_check.yaml ./
    ```

4. **Module Inclusion**: Ensure our module and its dependencies are included and properly set up in the container. For instance, add the Python module with:
    ```Dockerfile
    COPY ./simple_cod_module.py ./
    ```

5. **Dependency Management**: Install necessary dependencies, like the `requests` module. Choose between using `micromamba` for Conda environments or `pip` for Python environments.
    - For `micromamba`:
        ```Dockerfile
        RUN micromamba install -n qcrbox requests --yes
        ```
      If you have a large number of dependencies, working with a [conda .yml](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file) file is more sensible.
    - For `pip`:
        ```Dockerfile
        RUN pip install requests
        ```

6. **Delete unnecessary lines**: The following two lines are not necessary for a python application and should be deleted
    ```Dockerfile
    COPY sample_cmd.sh /opt/cod_check/bin/
    ````

    ```Dockerfile
    ENV PATH="$PATH:/opt/cod_check/bin/"
    ````

## Building the container with the first command exposed

To create a QCrBox image for our application, we'll execute a specific build command using the application slug defined earlier. Open your terminal and input the following command to start the build process:

```bash
qcb build cod_check
```

> **Important Note:** By default, `qcb build` without additional arguments performs a full rebuild of all dependencies to ensure everything is up-to-date. If you have recently completed a build and wish to save time, you can opt for the `--no-deps` argument. This option focuses solely on building the QCrBox image without updating the dependencies.

After completing the build process, you can launch your newly created QCrBox image with the following command:

```bash
qcb up cod_check --no-rebuild-deps
```

This command starts the container without recompiling the image or its dependencies, assuming they were recently built. If you aim to update both dependencies and the image before launching, simply omit the `--no-rebuild-deps` flag. This ensures that your QCrBox image and all related components are fully up-to-date.


## Build a function to load in a structure from the best matching unit cell

Our goal is to incorporate atomic parameters from the most compatible structure within the COD into our CIF file. This allows us to bypass the structure solution phase if matching information is readily available. To achieve this, we introduce a new command into the `config_cod_check.yaml` file. Append the following new command definition at the end of the file:

```YAML
  - name: "merge_closest_cod_entry"
    implemented_as: "python_callable"  # other options: "python_callable"
    parameters:
      - name: "input_cif_path"
        type: "str"
        default_value: None
      - name: "cellpar_deviation_perc"
        type: "float"
        default_value: 2.0
        required: false
      - name: "listed_elements_only"
        type: "bool"
        default_value: false
        required: false
    required_cif_entries: [
      "_cell_length_a", "_cell_length_b", "_cell_length_c", "_cell_angle_alpha",
      "_cell_angle_beta", "_cell_angle_gamma", "_chemical_formula_sum"
    ]
```

You might notice that our required cif entries are exactly the same, as they are used by the same function within the `simple_cod_module.py` file. This might be fine in this case, as the number of entries is rather low, However, we would like to only define the set of entries once. In QCrBox we can do that using cif_entry_sets. At the end of the file we create a new entry set for our commands:

```YAML
cif_entry_sets:
  - name: "cell_elements"
    required: [
      "_cell_length_a", "_cell_length_b", "_cell_length_c", "_cell_angle_alpha",
      "_cell_angle_beta", "_cell_angle_gamma", "_chemical_formula_sum"
    ]
```

Instead of writing the entries into the individual functions we now replace the `required_cif_entry` sections to have our command definition look like this:

```YAML
  - name: "merge_closest_cod_entry"
    implemented_as: "python_callable"  # other options: "python_callable"
    parameters:
      - name: "input_cif_path"
        type: "str"
        default_value: None
      - name: "cellpar_deviation_perc"
        type: "float"
        default_value: 2.0
        required: false
      - name: "listed_elements_only"
        type: "bool"
        default_value: false
        required: false
    required_cif_entry_sets: ["cell_elements"]
```

Try to update the definition of the `get_number_fitting_cod_entries` on your own. Note that you can have multiple cif entry sets. You can also combine entry sets with individual keywords to mix and match whatever your commands need.

## Developing the Python Glue Code for Our Merge Command.

We will now modify the `configure_cod_check.py` file to add the new functionality. We will use more functionality from both QCrBoxtools and our COD module. Our input section should now look like this:

```python
from qcrbox.registry.client import QCrBoxRegistryClient
from qcrboxtools.cif.cif2cif import (
    cif_file_unified_yml_instr,
    cif_file_unify_split,
)
from qcrboxtools.cif.merge import replace_structure_from_cif

from simple_cod_module import (
    cif_to_search_pars,
    get_number_fitting_cod_entries,
    get_fitting_cod_entries,
    download_cod_cif,
)
```

The `cif_file_unify_split` is the counterpart of the first function from cif2cif. We can use it to convert a non-unified cif to the unified set of entries. The `replace_structure_from_cif` function will do the actual replacement. The function `get_fitting_cod_entries` returns a list of dictionaries of cod entries, sorted by the sum of squared differences in the unit cell parameters. Finally, `download_cod_cif` can be used to download an entry from the cod.

We can now implement our function

```python
def merge_closest_cod_entry(input_cif_path, cellpar_deviation_perc, listed_elements_only):
    # cast the input parameters from strings to python objects
    work_cif_path, cellpar_deviation, listed_elements_only = parse_input(
        input_cif_path, cellpar_deviation_perc, listed_elements_only
    )

    # get the list of fitting entries
    elements, cell_dict = cif_to_search_pars(work_cif_path)
    entry_lst = get_fitting_cod_entries(elements, cell_dict, cellpar_deviation, listed_elements_only)

    # if no fitting entries found, raise an error
    if len(entry_lst) == 0:
        raise ValueError("No fitting entries found")

    # download the cif file of the most fitting entry
    cod_cif_path = work_cif_path.parent / "cod.cif"
    download_cod_cif(entry_lst[0]["file"], cod_cif_path)

    # convert to unified format
    unified_cod_path = work_cif_path.parent / "cod_unified.cif"
    cif_file_unify_split(
        cod_cif_path,
        unified_cod_path,
        custom_categories=["cod", "iucr", "olex2", "shelx"],
    )

    # replace structure from input cif with the one from cod cif
    replace_structure_from_cif(input_cif_path, 0, unified_cod_path, 0, work_cif_path.parent / "output.cif")
```

And finally we register that function with QCrBox by adding

```python
application.register_python_callable("merge_closest_cod_entry", merge_closest_cod_entry)
```

right before `client.run()`

## Rebuilding and Restarting the Container
If you have not done so you can shut down QCrBox by typing `qcb down`. You can now restart and rebuild the container by typing. Rebuilding without dependencies might be faster if you have just rebuid everything.

```bash
qcb up cod_check
```

## Conclusion and final remarks
We have now exposed two commands in QCrbox from a python module. One that only analyses a cif file to produce some output, and another one that works from an input cif file to an output cif. If you want to interact with what you have build, a ipython notebook you can put into the examples folder can be found [here.](./example_support/cod_wrapper.ipynb)

For more examples you might consider looking into the already implemented programs in `services/applications`. If this tutorial is unclear at any point please raise an issue on Github with the specific problem that you ran into.