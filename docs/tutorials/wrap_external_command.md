# Wrap an executable functionality to run within QCrBox

This guide walks you through the process of encapsulating a an external command within a QCrBox container. Specifically, we'll create a bash script that will allow as to run [CellCheckCSD](https://www.ccdc.cam.ac.uk/solutions/software/cellcheckcsd/) to produce an xml file with similar cells as output.

## Prerequisites

Before starting, ensure your development environment is set up following the guide located [here](../how_to_guides/set_up_a_dev_environment.md). During this tutorial you will work with Docker, Bash, and an understanding of YAML configurations. If you're new to these concepts you can just accept the additions as they are or consult additional resources on [Docker](https://docs.docker.com/get-started/overview/), [Bash](https://tldp.org/LDP/Bash-Beginners-Guide/html/), and [YAML](https://yaml.org/spec/1.2/spec.html) for foundational knowledge.

We will also need the linux version of CellCheckCSD from the [CSD Website](https://www.ccdc.cam.ac.uk/solutions/software/cellcheckcsd/). Download it and check that the filename / version number if it has changed you will have to adapt some steps accordingly.

## Initial Setup

To begin, initialize a new QCrBox container for our module:

1. Open your terminal.
2. Type `qcb init cellcheckcsd` and press Enter.
3. You will be prompted to provide basic information about your application through a guided dialogue. Follow the prompts to complete the setup. It does not change any functionality, but try to enter the correct version number of CellCheckCSD.

```
Please provide some basic information about your application.
The following dialog will guide you through the relevant settings.

  [1/7] Select application_type
    1 - CLI
    Choose from [1] (1):
  [2/7] application_slug (cellcheckcsd):
  [3/7] application_name (cellcheckcsd): CellCheckCSD
  [4/7] application_version (x.y.z): 1.2.14
  [6/7] url (): https://www.ccdc.cam.ac.uk/solutions/software/cellcheckcsd/
  [7/7] email ():

Created scaffolding for new application in 'T:\QCrBox_location\services\applications\cellcheckcsd'.
```
## Understanding the Generated Scaffolding

Navigate to the application's folder to see the files generated by the boilerplace CLI. You'll find:

- `docker-compose.cellcheckcsd.*.yml`: Docker Compose files, typically unchanged for non-GUI applications.
- `sample_cmd.sh`: An example bash file for CLI applications. This can be deleted.
- `Dockerfile`: Contains instructions to build the container.
- `config_cellcheckcsd.yaml`: Future versions will use this to define exposed functions. Currently, it requests CIF keywords.
- `configure_cellcheckcsd.py`: Here, we'll register our function. In future this will no longer be necessary.

Next, download the bash script we will use as an executable [here](./example_support/cif2cellcheckcsd.sh) and copy `cif2cellcheckcsd.sh` into the `cellcheckcsd` folder. Copy the downloaded version of CellCheckCSD into the folder, as well. If you are planning to develop and contribute to the QCrBox repository it is also a good idea to add the CellCheckCSD file to `.gitignore` to prevent the accidential commit of copyrighted material.

## Adding the Command to `config_cellcheckcsd.yaml`

We want a command that produces the xml output of CellCheckCSD for a given cif file. In a first step we will now adapt the configuration in `config_cellcheckcsd.yaml` to allow this functionality. First change the name of the first command to `cell_check_csd` and delete the second entry. We can take a look into the bash file to see which command line arguments are needed:

  1. input_cif_path (string): Identifies the CIF file employed for locating similar structures.
  2. dimension_tolerance (float): Specifies the maximum permissible deviation for unit cell length dimensions between the CSD structures and our target structure.
  3. angle_tolerance (float): Determines the maximum allowable deviation for angles.
  4. maximum_hits (int): Caps the number of search results.

Here is how you should structure the command in the YAML file:

```yaml
commands:
  - name: "cell_check_csd"
    implemented_as: "CLI"  # other options: "python_callable"
    parameters:
      - name: "input_cif_path"
        type: "str"
        default_value: None
      - name: "dimension_tolerace"
        type: "float"
        default_value: 1.5
        required: true
      - name: "angle_tolerance"
        type: "float"
        default_value: 1.5
        required: true
      - name: "maximum_hits"
        type: "int"
        default_value: 200
        required: true
```

### Specifying CIF Entries

Next, we must identify which CIF entries are essential for our command to function. You can take another look into the .sh file. As you can see, we need the CIF entries for the cell parameters. We can also use two possibilities to derive the lattice centring. If we have provided neither of them, we will default to "P". As such the cif entries for lattice centring are optional. For further information about cif entry handling consult the yaml section from the [CIF HowTo](../how_to_guides/handle_cifs.md). We add the required unit cell entries and the optional lattice centring entries to our yaml file. Take care that `required_cif_entries` and `optional_cif_entries` are aligned with `name`/`implemented_as`:

```yaml
    required_cif_entries: [
      "_cell.length_a", "_cell.length_b", "_cell.length_c", "_cell.angle_alpha",
      "_cell.angle_beta", "_cell.angle_gamma"
    ]
    optional_cif_entries: ["_space_group.centring_type", "_space_group.name_h-m_alt"]
    merge_cif_su: false
```

## Adding the Command to `configure_cellcheckcsd.py`

> **Important Note:**
> Some functionality that will eventually be automatedâ€”specifically, the registration of our application and commands in Python. At the moment this step is still necessary.

Next, we want to add a new command to our application's configuration file by replacing the dummy commands in  `configure_cellcheckcsd.py` with:

```python
cmd_cell_check_csd = ExternalCommand(
    "cif2cellcheckcsd.sh",
    Param("input_cif_path"),
    Param("dimension_tolerace"),
    Param("angle_tolerance"),
    Param("maximum_hits")
)

application.register_external_command(
    "cell_check_csd",
    cmd_cell_check_csd,
)
```

## Adapting the Dockerfile for CellCheckCSD Integration
We will now define the container's environment and ensuring all necessary components are included for our application by editing the Dockerfile. Let us go through the file line by line. You need to add missing lines.

1. **Establishing the Base Image**: The Dockerfile begins by specifying the base image. For our purposes, we use `qcrbox/base-application` as the foundation, selecting the latest version available for consistency and access to the most recent features.
   ```Dockerfile
   ARG QCRBOX_DOCKER_TAG
   FROM qcrbox/base-application:${QCRBOX_DOCKER_TAG}
   ```

2. **Changing the user to `root`**: Some of the following installation steps needs administrator priviledges. Therefore we execute them using the root user.
   ```Dockerfile
   USER root
   ```

3. **Configuring the Shell Environment**: It's essential to define the shell environment for executing future commands. Here, we specify using `/bin/bash`.
   ```Dockerfile
   SHELL ["/bin/bash", "-c"]
   ```

4. **Copying Configuration Files**: We copy both the Python configuration script and the YAML settings file into the container. These are the two files we have edited previously.
   ```Dockerfile
   COPY configure_cellcheckcsd.py ./
   COPY config_cellcheckcsd.yaml ./
   ```

5. **Dependency Installation**: The library `libglib2.0` is necessary for the proper functioning of CellCheckCSD. We can install the library using the package manager `apt-get`.
   ```Dockerfile
   RUN apt-get update -y && \
       apt-get install -y --fix-missing --no-install-recommends libglib2.0-0
   ```
   > **Note**: For reference, the QCrBox base image is build from the debian bookworm image.

6. **Script and Module Integration**: We now copy the custom bash script to run CellCheckCSD on CIF files. Additionally, we run the CellCheckCSD installer.
   - First, copy the bash script responsible for interfacing with CellCheckCSD:
     ```Dockerfile
     COPY cif2cellcheckcsd.sh /opt/cellcheckcsd/bin/
     ```
   - Then, execute the CellCheckCSD installer, followed by clean-up procedures to maintain a lean container. Make sure that the filename of the CellCheckCSD installer you download matches the filename here and adapt it if it does not match:
     ```Dockerfile
     COPY CellCheckCSD-1.2.14-linux-x64-installer.run ./
     RUN chmod +x ./CellCheckCSD-1.2.14-linux-x64-installer.run && \
         ./CellCheckCSD-1.2.14-linux-x64-installer.run --mode unattended --prefix /opt/CCDC/CellCheckCSD && \
         rm CellCheckCSD-1.2.14-linux-x64-installer.run && \
         chmod +x /opt/cellcheckcsd/bin/cif2cellcheckcsd.sh
     ```
    Ideally execution and clean-up should be executed within the same RUN command to limit the size of the resulting container. Be especially wary of chmod commands on (filled) directories.

    The last command makes our script an executable.

7. **Changing the user to the QCrBox user**: Runtime should not be executed in root. Not only are the elevated priviledges not necessary, some programs will get problems if we run them as the root user. So we change the user at the end to the QCrBox base user defined in our environment variables.
   ```Dockerfile
   USER ${QCRBOX_USER}
   ```

8. **Environment Path Adjustment**: Finally, we adjust the `PATH` environment variable to include the directories containing the CellCheckCSD executable and our custom script. This modification ensures that these components are readily accessible for execution within the container.
   ```Dockerfile
   USER ${QCRBOX_USER}
   ENV PATH="$PATH:/opt/cellcheckcsd/bin/:/opt/CCDC/CellCheckCSD/bin"
   ```

## Building the container with the first command exposed

To create a QCrBox image for our application, we'll execute a specific build command using the application slug defined earlier. Open your terminal and input the following command to start the build process:

```bash
qcb build cellcheckcsd
```

> **Important Note:** By default, `qcb build` without additional arguments performs a full rebuild of all dependencies to ensure everything is up-to-date. If you have recently completed a build and wish to save time, you can opt for the `--no-deps` argument. This option focuses solely on building the QCrBox image without updating the dependencies.

After completing the build process, you can launch your newly created QCrBox image with the following command:

```bash
qcb up cellcheckcsd --no-rebuild-deps
```

This command starts the container without recompiling the image or its dependencies, assuming they were recently built. If you aim to update both dependencies and the image before launching, simply omit the `--no-rebuild-deps` flag. This ensures that your QCrBox image and all related components are fully up-to-date.
