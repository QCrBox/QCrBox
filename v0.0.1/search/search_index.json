{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"<p>Welcome to QCrBox!</p> <p>QCrBox is an open-source platform aimed at revolutionizing general &amp; quantum crystallography by addressing the field's core challenges: complex workflows, software interoperability, and reproducibility barriers.</p> <p>QCrBox aims to facilitate the adoption of advanced crystallographic methods and spur the development of new tools by integrating existing software into a unified, containerized environment. Our goal is to streamline research processes, simplify software installation, enhance reproducibility, and improve reporting standards.</p> <p>We are currently working on completing the core framework. Feedback and collaboration is always welcome.</p> <p>Get in touch</p> <p>Do you have any questions, suggestions, want to get involved, or are simply curious to learn more?</p> <ul> <li>Join our Discord server to come and chat with us!</li> </ul>"},{"location":"#documentation","title":"Documentation:","text":"<ul> <li>How-To Guides (Start Here)</li> <li>Tutorials</li> <li>Technical Reference</li> <li>Background Information</li> </ul>"},{"location":"#technical-reference","title":"Technical reference:","text":"<ul> <li>Architectural Decision Records</li> <li>Changelog</li> </ul> <p>The documentation structure is based on the Divio Documentation System.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>This project aims to follow Semantic Versioning. However, there will be an initial period of stabilisation where this is not adhered to (releases with version numbers <code>0.0.x</code>).</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#new-features","title":"New Features","text":""},{"location":"CHANGELOG/#enhancements","title":"Enhancements","text":""},{"location":"CHANGELOG/#issues-fixed","title":"Issues Fixed","text":""},{"location":"CHANGELOG/#development","title":"Development","text":""},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>How-to guide on building and running components using the <code>qcb</code> command line tool. (#167)</li> </ul>"},{"location":"CHANGELOG/#v001","title":"v0.0.1","text":""},{"location":"CHANGELOG/#new-features_1","title":"New Features","text":"<ul> <li>Docker base images:<ul> <li><code>base-application</code></li> <li><code>base-novnc</code> #39</li> </ul> </li> <li>Core components:<ul> <li><code>qcrbox-message-bus</code> #9</li> <li><code>qcrbox-registry</code> #13</li> <li><code>qcrbox-nextflow</code> #60</li> <li><code>qcrboxtools</code> #120</li> </ul> </li> <li>Crystallographic applications:<ul> <li>CrystalExplorer #44</li> <li>Olex2 #46</li> <li>Eval #116</li> <li>XHARPy (#124)</li> </ul> </li> <li>CLI tool (<code>qcb</code>) for common development and deployment tasks. (#10, #164)</li> <li>Python package (<code>qcrbox</code>) to interact with QCrBox from Python code. (#14)</li> <li>The base image now includes cctbx and QCrBoxTools. (#53)</li> <li>Support for creating boilerplate scaffolding for new applications to be integrated with a QCrBox instance. (#75)</li> </ul>"},{"location":"CHANGELOG/#documentation_1","title":"Documentation","text":"<ul> <li>Created documentation skeleton. (#2)</li> <li>Set up GitHub Actions for continuous deployment of the docs to GitHub pages. (#11)</li> <li>Added README file. (#139)</li> <li>How-to guide on how to set up a development environment. (#24)</li> <li>How-to guide for using the cif building blocks provided by QCrBoxTools. (#71)</li> <li>Tutorial on how to integrate a command line program into QCrBox. (#79)</li> <li>Tutorial on how to integrate Python functionality into QCrBox. (#80</li> <li>Jupyter notebooks with examples on how to interact with commands exposed by QCrBox (for Olex2, Eval14/15, XHARPy, CrystalExplorer, QCrBoxTools). (#126)</li> </ul>"},{"location":"CHANGELOG/#bugs-fixed","title":"Bugs fixed","text":"<ul> <li>Ensured that the <code>qcb</code> tool works cross-platform, including on Windows. (#76)</li> <li>Line endings of text files checked out in the git working tree are always normalised to <code>LF</code> to avoid runtime errors on Windows. (#132)</li> <li>Command registration and internal error handling by the server. (#172)</li> <li>The build process using <code>qcb</code> on Windows has been fixed and made more robust. (#156)</li> </ul>"},{"location":"CHANGELOG/#internal-changes-improvements","title":"Internal changes &amp; improvements","text":"<ul> <li>The base images now use the mamba package manager, resulting in much faster build times than using <code>conda</code>.</li> <li>All QCrBox-specific Python packages are now installed in the base mamba environment. The separate Python virtual environment has been removed. (#54)</li> <li>Python code is linted and auto-formatted using ruff. #64</li> <li>Each application's docker compose configuration now lives in its dedicated subfolder (<code>services/application/&lt;application_folder&gt;</code>) instead of in the toplevel <code>docker-compose.yml</code> file. (#78)</li> <li>The folder structure in <code>qcrbox/cli/subcommands</code> has been simplified by removing an extra level of subfolders. (#90)</li> </ul>"},{"location":"ADRs/","title":"What are ADRs?","text":"<p>Architectural Decision Records (ADR's) provide a lightweight format for documenting the reasons why certain architectural or technical decisions were taken, and more importantly the context which led to these decisions. This allows to revisit these decisions later on, in case the context changes or more information becomes available. See Michael Nygard's blog post for more details on ADR's.</p> <p>Despite the name \"architectural decision records\", where appropriate it is also encouraged to document technological decisions (for example which Javascript framework to use for a web frontend) or \"cultural\" decisions.</p> <p>ADR's should be placed in sepearate files that are numbered sequentially (e.g. <code>0001-some-useful-description.md</code>). The contents should follow this template:</p> <ul> <li> <p>Title: short present tense imperative phrase, less than 50 characters, like a git commit message.</p> </li> <li> <p>Date: when was this issue discussed (to give approximate temporal context)</p> </li> <li> <p>Status: proposed, accepted, rejected, deprecated, superseded, etc.</p> </li> <li> <p>Context: what is the issue that we're seeing that is motivating this decision or change.   This section describes the forces at play, including technological, political, social, and project local. These forces are probably in tension, and should be called out as such. The language in this section is value-neutral. It is simply describing facts.</p> </li> <li> <p>Decision: what is the change that we're actually proposing or doing (describes our response to these forces)</p> </li> <li> <p>Consequences: what becomes easier or more difficult to do because of this change.   All consequences should be listed here, not just the \"positive\" ones. A particular decision may have positive, negative, and neutral consequences, but all of them affect the team and project in the future.</p> </li> </ul>"},{"location":"background_info/contents/","title":"Background Information","text":"<p>Info</p> <p>Background information:</p> <ul> <li>is understanding-oriented</li> <li>gives explanations</li> <li>provides background and context</li> </ul> <p>See here for context and details.</p>"},{"location":"background_info/contents/#contents","title":"Contents","text":""},{"location":"how_to_guides/contents/","title":"How-To Guides","text":"<p>Info</p> <p>A how-to guide:</p> <ul> <li>is goal-oriented</li> <li>shows how to solve a specific problem</li> <li>is a series of steps</li> </ul> <p>See here for context and details.</p>"},{"location":"how_to_guides/contents/#contents","title":"Contents","text":"<ul> <li>Setting up a development environment</li> <li>Building and running components using the <code>qcb</code> command line tool</li> <li>Working with cif files in QCrBox</li> </ul>"},{"location":"how_to_guides/handle_cifs/","title":"Working with cif files in QCrBox","text":"<p>QCrBox transfers data between containers using the crystallographic information file format (CIF). However, cif supports a number of aliases for the same entry. In addition some entries have been deprecated over the years. This provides a challenge for interoperability as one program within QCrBox might require a specific cif entry format for its input, while the software package that output the information might use another.</p>"},{"location":"how_to_guides/handle_cifs/#unified-cif-the-transfer-format","title":"Unified cif: The transfer format","text":"<p>As such we decided to convert all cif files to a state containing a unique set of keywords and split standard uncertainties (SUs). For the keyword names, we used the base definition of the current IUCr cif dictionaries, such as the cif_core.dic. Additionally, standard uncertainties are separated into their own keywords. This ensures that numerical convergence is actually possible.</p> <p>The following example entries should illustrate the convention:</p> <pre><code>data_old_format\n\n_cell_length_a     10.032(3)\n_cell_length_b      9.147(4)\n\n\ndata_unified_format\n\n_cell.length_a      10.032\n_cell.length_a_su    0.003\n_cell.length_b       9.147\n_cell.length_b_su    0.004\n</code></pre> <p>QCrBox does offer tools to convert between formats to make integration of software using any format as seamless as possible.</p>"},{"location":"how_to_guides/handle_cifs/#nomenclature-in-this-howto","title":"Nomenclature in this HowTo:","text":"<p>Unified CIF: See above</p> <p>Specific CIF CIF file create using specific keywords in a specific format, this can be the DDL1 style of keywords but it does not have to be.</p> <p>Specific CIF entry: A name of a cif entry in any convention that is contained within the CIF dictionaries. <code>_atom_site_fract_x</code> and <code>_atom_site.fract_x</code> are both valid specific cif entries.</p> <p>Required CIF entry: A specific CIF entry that is required to run a script or program. The QCrBoxTools functions will include the entry in the newly produced CIF file, if the unified CIF equivalent of that keyword is found. Otherwise they will throw an error.</p> <p>Optional CIF entry: A specific CIF entry that might be used by a script or program. Will be included if the unified CIF equivalent is present and otherwise ignored.</p> <p>Split SUs: Splitting the standard uncertainties into their own keywords.</p> <p>Merge SUs: Combining a keyword with a standard uncertainty keyword to get the bracket notation.</p> <p>Custom CIF categories: Programs or organisations might define their own CIF entries in their own namespace. The old convention is using an underscore after the namespace e.g. <code>_qcrbox_my_value</code>, while the new convention is <code>qcrbox.my_value</code>. Listing the categories as a custom category without a leading underscore will insure the correct back and forth conversion between the two.</p>"},{"location":"how_to_guides/handle_cifs/#converting-to-unified-cif-using-the-qcrboxtools-container","title":"Converting to Unified CIF using the QCrBoxtools container","text":"<p>If you want to convert your cif file into the unified cif format without any more knowledge, there is an example IPython notebook that shows you how to do that, by using the exposed <code>to_unified_cif</code> command of that container.</p>"},{"location":"how_to_guides/handle_cifs/#converting-cif-files-using-the-qcrboxtools-python-library","title":"Converting CIF files using the QCrBoxTools Python Library","text":"<p>The QCrBoxTools library is available within the python environment of every QCrBox container. It can be called either via a command line interface or within a python script. Additionally you can also install the library outside of QCrBox by getting the source here and installing it into your local python environment.</p>"},{"location":"how_to_guides/handle_cifs/#using-the-command-line-interface","title":"Using the command line interface","text":"<p>The command line interface can be called by invoking: <pre><code>python -m qcrboxtools.cif &lt;cmd&gt; &lt;input_cif_path&gt; &lt;output_cif_path&gt; &lt;ARGS&gt;\n</code></pre> Invoke with <code>--help</code> instead of arguments to see the available options.</p>"},{"location":"how_to_guides/handle_cifs/#using-the-python-library","title":"Using the python library.","text":"<p>The required functions are located within the <code>qcrboxtools.cif.cif2cif</code> module if you want to work from and to files and in <code>qcrboxtools.cif.entries</code> and <code>qcrboxtools.cif.uncertainties</code> if you want to work with <code>iotbx.cif</code> objects. The docstrings of the functions should be covering the use cases. If they are unclear, please raise a GitHub issue.</p>"},{"location":"how_to_guides/handle_cifs/#working-with-qcrbox-configyml-files","title":"Working with QCrBox <code>config*.yml</code> files","text":"<p>This section will focus on how to work with the CIF capabilities of the yaml file. For parameter definition look into the tutorial.</p> <p>The yaml file can contain the following options in a command:</p> <pre><code>commands:\n  - name: \"my_command\"\n    implemented_as: \"CLI/python_callable/GUI\"\n    parameters:\n      # Definition covered in tutorial\n    required_cif_entries: [\"_some_entry\", \"_some_other_entry\"]\n    optional_cif_entries: [\"_some_entry_su\"]\n    required_cif_entry_sets: [\"cell_data\", \"diffraction_data\"]\n    optional_cif_entry_sets: [\"atom_data\"]\n    merge_cif_su: Yes\n    custom_cif_categories: [\"iucr\", \"shelx\"]\n</code></pre> <p>Let us go through the options line by line:</p> <ul> <li> <p><code>name</code>: The QCrBoxTools function working with CIF require a command name or command. This is that name</p> </li> <li> <p><code>required_cif_entries</code>: List of specific CIF entries to include (see Nomenclature)</p> </li> <li> <p><code>optional_cif_entries</code>: List of specific CIF entries to include when present (see Nomenclature)</p> </li> <li> <p><code>required_cif_entry_sets</code>: List of CIF entry sets to include. All required entries will be treated as required and optional entries will be included as optional. (For definition of entry sets see next section).</p> </li> <li> <p><code>optional_cif_entry_sets</code>: List of CIF entry sets to include. All required entries and optional entries will be included as optional. (For definition of entry sets see next section).</p> </li> <li> <p><code>merge_cif_su</code>: If set to <code>Yes</code>, the standard uncertainty entries will be merged with the base entry using bracket notation, unless the standard uncertainty is requested separately as its own entry. So in the example above <code>_some_entry</code> would not be merged with a present standard uncertainty entry, both <code>_some_entry</code> and <code>_some_entry_su</code> are included separately. <code>_some_other_entry</code> would be merged if an SU was present.</p> </li> <li> <p><code>custom_cif_categories</code>: List of custom CIF categories to include in the output cif file (see Nomenclature).</p> </li> </ul>"},{"location":"how_to_guides/handle_cifs/#cif-entry-sets-in-a-yaml-file","title":"CIF entry sets in a YAML file","text":"<p>In order to keep the command definition somewhat compact and not redefine entries shared between commands, the YML also contains the possibility to define cif entry sets. The syntax is:</p> <pre><code>cif_entry_sets:\n  - name: \"cell_data\"\n    required : [\"_required_entry\"]\n    optional : [\"_optional_entry\"]\n</code></pre> <p>The <code>name</code> is the name of the set, which can be used in the command definition. The <code>required</code> and <code>optional</code> lists are lists of specific CIF entries to include in the set (see Nomenclature).</p>"},{"location":"how_to_guides/set_up_a_dev_environment/","title":"Setting up a development environment","text":""},{"location":"how_to_guides/set_up_a_dev_environment/#check-prerequisites","title":"Check prerequisites","text":"<p>Make sure you have the necessary prerequisites installed.</p> <p>Info</p> <p>QCrBox has been tested with the versions of Python and Docker listed here, but other recent versions should also work. Please raise an issue on GitHub if you experience any problems.</p> <pre><code>$ python --version\nPython 3.11.5\n\n$ docker --version\nDocker version 24.0.6, build ed223bc\n\n$ docker compose version\nDocker Compose version v2.21.0\n</code></pre>"},{"location":"how_to_guides/set_up_a_dev_environment/#clone-the-qcrbox-repository","title":"Clone the QCrBox repository","text":"<pre><code>$ git clone https://github.com/QCrBox/QCrBox.git\n$ cd QCrBox\n</code></pre>"},{"location":"how_to_guides/set_up_a_dev_environment/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>Create a virtual environment for the <code>qcrbox</code> Python package and activate it.</p> Linux/Mac OSWindows (Powershell)Windows (command line) <pre><code>$ python -m venv ./venv\n$ source ./venv/bin/activate\n</code></pre> <pre><code>$ python -m venv .\\venv\n$ .\\venv\\Scripts\\activate.ps1\n</code></pre> <pre><code>$ python -m venv .\\venv\n$ .\\venv\\Scripts\\activate.bat\n</code></pre> <p>Note</p> <p>In this guide we use a \"vanilla\" Python virtual environment because it does not require any additional dependencies. If you use a custom package manager such as <code>poetry</code> or <code>conda</code> you can of course adapt the previous step to your specific setup.</p> <p>Let's also update <code>pip</code> to its latest version and install the <code>uv</code> package installer (which is much faster than the standard <code>pip</code> installer). <pre><code>(venv) $ python -m pip install --upgrade pip uv\n</code></pre></p>"},{"location":"how_to_guides/set_up_a_dev_environment/#install-the-qcrbox-python-package","title":"Install the <code>qcrbox</code> Python package","text":"<p>Next, install the <code>qcrbox</code> package itself. <pre><code>$ uv pip install -e ./qcrbox[all]\n</code></pre> This command installs the <code>qcb</code> command line tool, which acts as the command line interface for the Quantum Crystallography Toolbox, together with all extra dependencies needed for  development. These extra dependencies include developer tools for testing, code formatting and linting; packages needed to run the QCrBox server &amp; client locally, and packages needed to build and serve the documentation.</p> <p>Note</p> <p>The above command uses the <code>-e</code> switch to install <code>qcrbox</code> in editable mode. This means that any changes we make to the code during development are automatically picked up in our local installation without having to reinstall/upgrade the <code>qcrbox</code> package.</p>"},{"location":"how_to_guides/set_up_a_dev_environment/#alternative-installation-with-minimal-dependencies","title":"Alternative: installation with minimal dependencies","text":"<p>If you only care about being able to run the <code>qcb</code> command line tool (which is needed in order to build and run the QCrBox docker containers) but not about any other development capabilities, you can choose to install <code>qcrbox</code> with only a minimal set of dependencies as follows. <pre><code>(venv) $ uv pip install -e ./qcrbox\n</code></pre></p>"},{"location":"how_to_guides/set_up_a_dev_environment/#alternative-installation-with-targeted-sets-of-extra-dependencies","title":"Alternative: installation with targeted sets of extra dependencies","text":"<p>QCrBox comes with several other sets of additional dependencies which can be specified in square brackets after <code>qcrbox</code>.</p> <p>If you only want to be able to build the documentation, for example, run the following command. <pre><code>(venv) $ uv pip install -e ./qcrbox[docs]\n</code></pre></p> <p>If you plan on developing QCrBox, making modifications to the code and/or submitting merge requests, you most likely want to install the <code>dev</code> dependencies, too. <pre><code>(venv) $ uv pip install -e ./qcrbox[dev]\n</code></pre></p> <p>Two other sets of additional dependencies are <code>qcrbox[client]</code> and <code>qcrbox[server]</code>, but these are mostly relevant for targeted installation inside the Docker containers.</p>"},{"location":"how_to_guides/set_up_a_dev_environment/#installing-pre-commit-hooks-for-development-on-qcrbox","title":"Installing pre-commit hooks (for development on <code>qcrbox</code>)","text":"<p>For development on <code>qcrbox</code>, you need to install the pre-commit hooks for linting, auto-formatting, etc. Make sure you have the dev dependencies installed (as described above), which ensures that the <code>pre-commit</code> tool is installed. Then run: <pre><code>(venv) $ pre-commit install\n</code></pre> Now <code>pre-commit</code> will run automatically on <code>git commit</code>.</p>"},{"location":"how_to_guides/set_up_a_dev_environment/#verify-the-installation","title":"Verify the installation","text":"<p>Verify that we can now run the <code>qcb</code> command line tool, which is the main CLI interface for interacting with QCrBx from the command line.</p> <pre><code>$ qcb\nUsage: qcb [OPTIONS] COMMAND [ARGS]...\n\n  Command line interface for the Quantum Crystallography Toolbox.\n\nOptions:\n  -v, --verbose  Enables verbose mode (will print debugging messages about\n                 actions performed). [default: False]\n  -h, --help     Show this message and exit.\n\nCommands:\n  build    Build QCrBox components.\n  docs     Build/serve the documentation.\n  down     Shut down QCrBox components.\n  init     Create boilerplate template for a new application.\n  invoke   Invoke a registered command with given arguments.\n  list     List registered resources (applications, commands, etc.)\n  up       Start up QCrBox components.\n  version  Print the qcrbox version.\n</code></pre> <pre><code>$ qcb version\n0.0.2.dev0+g6fd2b03.d20240326\n</code></pre> <pre><code>$ qcb list components\nqcrbox-message-bus\nqcrbox-registry\nqcrbox-nextflow\ncrystal-explorer\neval1x\nolex2\nqcrboxtools\nshelx\nxharpy-gpaw\n</code></pre> <pre><code>$ qcb list components --all\nbase-ancestor\nbase-application\nbase-novnc\nqcrbox-message-bus\nqcrbox-registry\nqcrbox-nextflow\ncrystal-explorer\neval1x\nolex2\nqcrboxtools\nshelx\nxharpy-gpaw\n</code></pre>"},{"location":"how_to_guides/set_up_a_dev_environment/#build-a-container-to-test-the-installation","title":"Build a container to test the installation","text":"<p>Try building a component by typing: <pre><code>$ qcb build qcrboxtools\n</code></pre></p> <p>Warning</p> <p>There were issues with running hatchling under Windows 11, especially when using a Python version from the Windows Store. If <code>qcb build</code> fails during <code>Building Python package: qcrbox</code> with a code 106 error (or silently when running without <code>-v</code>), try the following remedy:</p> <ol> <li>Uninstall the Windows Store Python version using the app uninstall of Windows</li> <li>Get a new installer from python.org</li> <li>Install. Activate support for long paths and add Python to path</li> <li>Delete the venv folder and create a new one with the new Python version</li> </ol>"},{"location":"how_to_guides/use_qcb_to_interact_with_and_manage_qcrbox/","title":"Building and running QCrBox components using the <code>qcb</code> command line tool","text":"<p>Note</p> <p>Make sure you have followed the steps in Setting up a development environment and you can run <code>qcb --help</code> successfully. As a general rule, <code>qcb</code> should be run from within the cloned QCrBox git repository (typically from the toplevel folder, although this is not required).</p>"},{"location":"how_to_guides/use_qcb_to_interact_with_and_manage_qcrbox/#listing-available-qcrbox-components","title":"Listing available QCrBox components","text":"<p>Let's check which components are available in QCrBox. <pre><code>$ qcb list components\nqcrbox-message-bus\nqcrbox-registry\nqcrbox-nextflow\ncrystal-explorer\neval1x\nolex2\nqcrboxtools\nshelx\nxharpy-gpaw\n</code></pre></p> <p>This list contains three \"core\" components (<code>qcrbox-message-bus</code>, <code>qcrbox-registry</code>, <code>qcrbox-nextflow</code>). You don't need to worry about these for using and interacting with QCrBox - they will be started automatically when you spin up the crystallographic application components.</p> <p>The remaining components represent existing crystallographic software packages that are accessible from QCrBox. <pre><code>crystal-explorer\neval1x\nolex2\nqcrboxtools\nshelx\nxharpy-gpaw\n</code></pre></p>"},{"location":"how_to_guides/use_qcb_to_interact_with_and_manage_qcrbox/#building-components","title":"Building components","text":"<p>You can build the Docker image for a given component by running <code>qcb build</code>. For example, let's build the docker image for Olex2. Before we run the actual build, let's use the <code>--dry-run</code> flag to inspect what would happen. <pre><code>$ qcb build --dry-run olex2\nWould build the following components (including dependencies): olex2\n\nDRY-RUN | INFO     | Would build Python package: qcrbox\nDRY-RUN | INFO     | Would pull/clone QCrBoxTools repo in /Users/maxalbert/work/code/RSG_work/QCrBox/.build/QCrBoxTools ...\nDRY-RUN | INFO     | Would build Python package: qcrboxtools\nDRY-RUN | INFO     | Would build docker image: base-ancestor\nDRY-RUN | INFO     | Would build docker image: base-application\nDRY-RUN | INFO     | Would build docker image: base-novnc\nDRY-RUN | INFO     | Would build docker image: qcrbox-message-bus\nDRY-RUN | INFO     | Would build docker image: qcrbox-registry\nDRY-RUN | INFO     | Would build docker image: olex2\n</code></pre></p> <p>You will notice that the logging output mentions additional Python packages and docker images. These are prerequisites for running application containers such as Olex2. The <code>qcb</code> tool knows about their dependencies and builds them automatically. You can pass the <code>--no-deps</code> flag to only build Olex2 itself (this can speed up the build during development if you are certain that the dependencies are already up-to-date). <pre><code>$ qcb build --dry-run --no-deps olex2\nWould build the following components (without dependencies): olex2\n\nDRY-RUN | INFO     | Would build docker image: olex2\n</code></pre></p> <p>Ok, let's run the actual build process by removing the <code>--dry-run</code> flag. Note that the first time this command is executed it may take a few minutes to complete. <pre><code>$ qcb build olex2\n</code></pre></p> <p>Alternatively, if you want to build all available components, run: <pre><code>$ qcb build --all\n</code></pre></p> <p>Note</p> <p>Certain components such as SHELX and Eval are disabled by default because they require password access for downloading executables or source code. These components will be skipped (even when using <code>--all</code>) unless the <code>--enable</code> flag is passed explicitly for each of these components that you'd like to enable. For example: <pre><code>$ qcb build --all --enable=shelx --enable=evl1x\n</code></pre></p> <p>Warning</p> <p>Building components that are disabled by default may require you to set certain environment variables or download password-protected files manually and placing them in the correct location. We will provide much better support for this in the future as part of the <code>qcb</code> toolchain. For the time being, please get in touch if you would like to build these and need support.</p>"},{"location":"how_to_guides/use_qcb_to_interact_with_and_manage_qcrbox/#starting-up-containers","title":"Starting up containers","text":"<p>You can start the Docker container for Olex2 by running: <pre><code>$ qcb up olex2\n</code></pre> As above, if you want to start all (enabled) components, use the <code>--all</code> flag: <pre><code>$ qcb up --all\n</code></pre></p> <p>Warning</p> <p>If you want start up containers after previously shutting them down (using <code>qcb down</code> as described below), you must currently manually delete the Docker volume where the QCrBox server stores information about available components:</p> <pre><code># Step 1: Shut down all running containers\n$ qcb down\n\n# Step 2: Delete the Docker volume containing the QCrBox server database\n$ docker volume rm qcrbox_qcrbox-registry-db\n\n# Step 3: Now you can start up the components again and things should work as expected.\n$ qcb up --all\n</code></pre> <p>This is of course less than ideal. The underlying issue is being addressed in a refactoring branch that will be merged very soon, at which point you will be able to shut down and spin up components ad libitum without manual intervention.</p>"},{"location":"how_to_guides/use_qcb_to_interact_with_and_manage_qcrbox/#shutting-down-containers","title":"Shutting down containers","text":"<p>Run the following command to shut down all running QCrBox containers: <pre><code>$ qcb down\n</code></pre></p>"},{"location":"how_to_guides/use_qcb_to_interact_with_and_manage_qcrbox/#next-steps","title":"Next steps","text":"<ul> <li> <p>Navigate to the following URL to get a fully functioning Olex2 GUI running inside your browser:</p> <p>http://localhost:12004/vnc.html?path=vnc&amp;autoconnect=true&amp;resize=remote&amp;reconnect=true&amp;show_dot=true</p> </li> <li> <p>Read the Tutorials to see several examples showing how to interact programmatically with crystallographic software within QCrBox.</p> </li> </ul>"},{"location":"technical_reference/contents/","title":"Technical Reference","text":"<p>Info</p> <p>Technical reference:</p> <ul> <li>is information-oriented</li> <li>describes the machinery</li> <li>is accurate and complete</li> </ul> <p>See here for context and details.</p>"},{"location":"technical_reference/contents/#contents","title":"Contents","text":""},{"location":"tutorials/contents/","title":"Tutorials","text":"<p>Info</p> <p>A tutorial:</p> <ul> <li>is learning-oriented</li> <li>allows newcomers to get started</li> <li>is a lesson</li> </ul> <p>See here for context and details.</p>"},{"location":"tutorials/contents/#contents","title":"Contents","text":"<ul> <li>Integrating a command line (CLI) program into QCrBox</li> <li>Integrating Python functionality into QCrBox</li> <li>Examples for interacting with crystallographic software within QCrBox:<ul> <li>Example: interacting with Olex2</li> <li>Example: interacting with XHARPy</li> <li>Example: interacting with Eval 14/15</li> <li>Example: interacting with CrystalExplorer</li> <li>Example: interacting with QCrBoxTools</li> </ul> </li> </ul>"},{"location":"tutorials/wrap_external_command/","title":"Wrapping a command line executable to run within QCrBox","text":"<p>This guide walks you through the process of encapsulating an external command within a QCrBox container. Specifically, we'll create a bash script that will allow as to run CellCheckCSD to produce an xml file with similar cells as output.</p>"},{"location":"tutorials/wrap_external_command/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure your development environment is set up following the guide located here. During this tutorial you will work with Docker, Bash, and an understanding of YAML configurations. If you're new to these concepts you can just accept the additions as they are or consult additional resources on Docker, Bash, and YAML for foundational knowledge.</p> <p>We will also need the linux version of CellCheckCSD from the CSD Website. Download it and check that the filename / version number if it has changed you will have to adapt some steps accordingly.</p>"},{"location":"tutorials/wrap_external_command/#initial-setup","title":"Initial Setup","text":"<p>To begin, initialize a new QCrBox container for our module:</p> <ol> <li>Open your terminal.</li> <li>Type <code>qcb init cellcheckcsd</code> and press Enter.</li> <li>You will be prompted to provide basic information about your application through a guided dialogue. Follow the prompts to complete the setup. It does not change any functionality, but try to enter the correct version number of CellCheckCSD.</li> </ol> <pre><code>Please provide some basic information about your application.\nThe following dialog will guide you through the relevant settings.\n\n  [1/7] Select application_type\n    1 - CLI\n    Choose from [1] (1):\n  [2/7] application_slug (cellcheckcsd):\n  [3/7] application_name (cellcheckcsd): CellCheckCSD\n  [4/7] application_version (x.y.z): 1.2.14\n  [6/7] url (): https://www.ccdc.cam.ac.uk/solutions/software/cellcheckcsd/\n  [7/7] email ():\n\nCreated scaffolding for new application in 'T:\\QCrBox_location\\services\\applications\\cellcheckcsd'.\n</code></pre>"},{"location":"tutorials/wrap_external_command/#understanding-the-generated-scaffolding","title":"Understanding the Generated Scaffolding","text":"<p>Navigate to the application's folder to see the files generated by the boilerplace CLI. You'll find:</p> <ul> <li><code>docker-compose.cellcheckcsd.*.yml</code>: Docker Compose files, typically unchanged for non-GUI applications.</li> <li><code>sample_cmd.sh</code>: An example bash file for CLI applications. This can be deleted.</li> <li><code>Dockerfile</code>: Contains instructions to build the container.</li> <li><code>config_cellcheckcsd.yaml</code>: Future versions will use this to define exposed functions. Currently, it requests CIF keywords.</li> <li><code>configure_cellcheckcsd.py</code>: Here, we'll register our function. In future this will no longer be necessary.</li> </ul> <p>Next, download the bash script we will use as an executable here and copy <code>cif2cellcheckcsd.sh</code> into the <code>cellcheckcsd</code> folder. Copy the downloaded version of CellCheckCSD into the folder, as well. If you are planning to develop and contribute to the QCrBox repository it is also a good idea to add the CellCheckCSD file to <code>.gitignore</code> to prevent the accidential commit of copyrighted material.</p>"},{"location":"tutorials/wrap_external_command/#adding-the-command-to-config_cellcheckcsdyaml","title":"Adding the Command to <code>config_cellcheckcsd.yaml</code>","text":"<p>We want a command that produces the xml output of CellCheckCSD for a given cif file. In a first step we will now adapt the configuration in <code>config_cellcheckcsd.yaml</code> to allow this functionality. First change the name of the first command to <code>cell_check_csd</code> and delete the second entry. We can take a look into the bash file to see which command line arguments are needed:</p> <ol> <li>input_cif_path (string): Identifies the CIF file employed for locating similar structures.</li> <li>dimension_tolerance (float): Specifies the maximum permissible deviation for unit cell length dimensions between the CSD structures and our target structure.</li> <li>angle_tolerance (float): Determines the maximum allowable deviation for angles.</li> <li>maximum_hits (int): Caps the number of search results.</li> </ol> <p>Here is how you should structure the command in the YAML file:</p> <pre><code>commands:\n  - name: \"cell_check_csd\"\n    implemented_as: \"CLI\"  # other options: \"python_callable\"\n    parameters:\n      - name: \"input_cif_path\"\n        type: \"str\"\n        default_value: None\n      - name: \"dimension_tolerace\"\n        type: \"float\"\n        default_value: 1.5\n        required: true\n      - name: \"angle_tolerance\"\n        type: \"float\"\n        default_value: 1.5\n        required: true\n      - name: \"maximum_hits\"\n        type: \"int\"\n        default_value: 200\n        required: true\n</code></pre>"},{"location":"tutorials/wrap_external_command/#specifying-cif-entries","title":"Specifying CIF Entries","text":"<p>Next, we must identify which CIF entries are essential for our command to function. You can take another look into the .sh file. As you can see, we need the CIF entries for the cell parameters. We can also use two possibilities to derive the lattice centring. If we have provided neither of them, we will default to \"P\". As such the cif entries for lattice centring are optional. For further information about cif entry handling consult the yaml section from the CIF HowTo. We add the required unit cell entries and the optional lattice centring entries to our yaml file. Take care that <code>required_cif_entries</code> and <code>optional_cif_entries</code> are aligned with <code>name</code>/<code>implemented_as</code>:</p> <pre><code>    required_cif_entries: [\n      \"_cell.length_a\", \"_cell.length_b\", \"_cell.length_c\", \"_cell.angle_alpha\",\n      \"_cell.angle_beta\", \"_cell.angle_gamma\"\n    ]\n    optional_cif_entries: [\"_space_group.centring_type\", \"_space_group.name_h-m_alt\"]\n    merge_cif_su: false\n</code></pre>"},{"location":"tutorials/wrap_external_command/#adding-the-command-to-configure_cellcheckcsdpy","title":"Adding the Command to <code>configure_cellcheckcsd.py</code>","text":"<p>Important Note: Some functionality that will eventually be automated\u2014specifically, the registration of our application and commands in Python. At the moment this step is still necessary.</p> <p>Next, we want to add a new command to our application's configuration file by replacing the dummy commands in  <code>configure_cellcheckcsd.py</code> with:</p> <pre><code>cmd_cell_check_csd = ExternalCommand(\n    \"cif2cellcheckcsd.sh\",\n    Param(\"input_cif_path\"),\n    Param(\"dimension_tolerace\"),\n    Param(\"angle_tolerance\"),\n    Param(\"maximum_hits\")\n)\n\napplication.register_external_command(\n    \"cell_check_csd\",\n    cmd_cell_check_csd,\n)\n</code></pre>"},{"location":"tutorials/wrap_external_command/#adapting-the-dockerfile-for-cellcheckcsd-integration","title":"Adapting the Dockerfile for CellCheckCSD Integration","text":"<p>We will now define the container's environment and ensuring all necessary components are included for our application by editing the Dockerfile. Let us go through the file line by line. You need to add missing lines.</p> <ol> <li> <p>Establishing the Base Image: The Dockerfile begins by specifying the base image. For our purposes, we use <code>qcrbox/base-application</code> as the foundation, selecting the latest version available for consistency and access to the most recent features.    <pre><code>ARG QCRBOX_DOCKER_TAG\nFROM qcrbox/base-application:${QCRBOX_DOCKER_TAG}\n</code></pre></p> </li> <li> <p>Changing the user to <code>root</code>: Some of the following installation steps needs administrator priviledges. Therefore we execute them using the root user.    <pre><code>USER root\n</code></pre></p> </li> <li> <p>Configuring the Shell Environment: It's essential to define the shell environment for executing future commands. Here, we specify using <code>/bin/bash</code>.    <pre><code>SHELL [\"/bin/bash\", \"-c\"]\n</code></pre></p> </li> <li> <p>Copying Configuration Files: We copy both the Python configuration script and the YAML settings file into the container. These are the two files we have edited previously.    <pre><code>COPY configure_cellcheckcsd.py ./\nCOPY config_cellcheckcsd.yaml ./\n</code></pre></p> </li> <li> <p>Dependency Installation: The library <code>libglib2.0</code> is necessary for the proper functioning of CellCheckCSD. We can install the library using the package manager <code>apt-get</code>.    <pre><code>RUN apt-get update -y &amp;&amp; \\\n    apt-get install -y --fix-missing --no-install-recommends libglib2.0-0\n</code></pre></p> <p>Note: For reference, the QCrBox base image is build from the debian bookworm image.</p> </li> <li> <p>Script and Module Integration: We now copy the custom bash script to run CellCheckCSD on CIF files. Additionally, we run the CellCheckCSD installer.</p> </li> <li>First, copy the bash script responsible for interfacing with CellCheckCSD:      <pre><code>COPY cif2cellcheckcsd.sh /opt/cellcheckcsd/bin/\n</code></pre></li> <li> <p>Then, execute the CellCheckCSD installer, followed by clean-up procedures to maintain a lean container. Make sure that the filename of the CellCheckCSD installer you download matches the filename here and adapt it if it does not match:      <pre><code>COPY CellCheckCSD-1.2.14-linux-x64-installer.run ./\nRUN chmod +x ./CellCheckCSD-1.2.14-linux-x64-installer.run &amp;&amp; \\\n    ./CellCheckCSD-1.2.14-linux-x64-installer.run --mode unattended --prefix /opt/CCDC/CellCheckCSD &amp;&amp; \\\n    rm CellCheckCSD-1.2.14-linux-x64-installer.run &amp;&amp; \\\n    chmod +x /opt/cellcheckcsd/bin/cif2cellcheckcsd.sh\n</code></pre>     Ideally execution and clean-up should be executed within the same RUN command to limit the size of the resulting container. Be especially wary of chmod commands on (filled) directories.</p> <p>The last command makes our script an executable.</p> </li> <li> <p>Changing the user to the QCrBox user: Runtime should not be executed in root. Not only are the elevated priviledges not necessary, some programs will get problems if we run them as the root user. So we change the user at the end to the QCrBox base user defined in our environment variables.    <pre><code>USER ${QCRBOX_USER}\n</code></pre></p> </li> <li> <p>Environment Path Adjustment: Finally, we adjust the <code>PATH</code> environment variable to include the directories containing the CellCheckCSD executable and our custom script. This modification ensures that these components are readily accessible for execution within the container.    <pre><code>USER ${QCRBOX_USER}\nENV PATH=\"$PATH:/opt/cellcheckcsd/bin/:/opt/CCDC/CellCheckCSD/bin\"\n</code></pre></p> </li> </ol> <p>Note: If your application is compiled within the container you can reduce the size of the resulting containers by using multi-stage builds.</p>"},{"location":"tutorials/wrap_external_command/#building-the-container-with-the-first-command-exposed","title":"Building the container with the first command exposed","text":"<p>To create a QCrBox image for our application, we'll execute a specific build command using the application slug defined earlier. Open your terminal and input the following command to start the build process:</p> <pre><code>qcb build cellcheckcsd\n</code></pre> <p>Important Note: By default, <code>qcb build</code> without additional arguments performs a full rebuild of all dependencies to ensure everything is up-to-date. If you have recently completed a build and wish to save time, you can opt for the <code>--no-deps</code> argument. This option focuses solely on building the QCrBox image without updating the dependencies.</p> <p>After completing the build process, you can launch your newly created QCrBox image with the following command:</p> <pre><code>qcb up cellcheckcsd --no-rebuild-deps\n</code></pre> <p>This command starts the container without recompiling the image or its dependencies, assuming they were recently built. If you aim to update both dependencies and the image before launching, simply omit the <code>--no-rebuild-deps</code> flag. This ensures that your QCrBox image and all related components are fully up-to-date.</p>"},{"location":"tutorials/wrap_python_command/","title":"Wrapping a Python module and exposing functionality to run within QCrBox","text":"<p>This guide walks you through the process of encapsulating a Python module within a QCrBox container. Specifically, we'll focus on a module that queries the Crystallographic Open Database (COD) for structures with similar elements and unit cell parameters. Our goal is to make this module's functionality accessible within a QCrBox container.</p>"},{"location":"tutorials/wrap_python_command/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure your development environment is set up following the guide located here. During this tutorial you will work with Docker, Python, and an understanding of YAML configurations. If you're new to these concepts you can just accept the additions as they are or consusult additional resources on Docker, Python modules, and YAML for foundational knowledge.</p>"},{"location":"tutorials/wrap_python_command/#initial-setup","title":"Initial Setup","text":"<p>To begin, initialize a new QCrBox container for our module:</p> <ol> <li>Open your terminal.</li> <li>Type <code>qcb init cod_check</code> and press Enter.</li> <li>You will be prompted to provide basic information about your application through a guided dialogue. Follow the prompts to complete the setup.</li> </ol> <pre><code>Please provide some basic information about your application.\nThe following dialog will guide you through the relevant settings.\n\n  [1/7] Select application_type\n    1 - CLI\n    Choose from [1] (1): 1\n  [2/7] application_slug (cod_check):\n  [3/7] application_name (Cod Check): COD Check\n  [4/7] application_version (x.y.z): 0.0.1\n  [5/7] description (Brief description of the application.): Can be used to check whether there is a similar structure in the crystallographic open database and output similar structures.\n  [6/7] url (): https://my.official.module.url\n  [7/7] email (): module_contact@university.somewhere\n\nCreated scaffolding for new application in 'T:\\QCrBox_location\\services\\applications\\cod_check'.\n</code></pre>"},{"location":"tutorials/wrap_python_command/#understanding-the-generated-scaffolding","title":"Understanding the Generated Scaffolding","text":"<p>Navigate to the application's folder to see the files generated by the boilerplace CLI. You'll find:</p> <ul> <li><code>docker-compose.cod_check.*.yml</code>: Docker Compose files, typically unchanged for non-GUI applications.</li> <li><code>sample_cmd.sh</code>: An example bash file for CLI applications. This can be deleted.</li> <li><code>Dockerfile</code>: Contains instructions to build the container.</li> <li><code>config_cod_check.yaml</code>: Future versions will use this to define exposed functions. Currently, it requests CIF keywords.</li> <li><code>configure_cod_check.py</code>: Here, we'll implement our module's functionality and register it with QCrBox.</li> </ul> <p>Next, download the Python file here and copy <code>simple_cod_module.py</code> into the <code>cod_check</code> folder.</p>"},{"location":"tutorials/wrap_python_command/#adding-the-first-command-to-config_cod_checkyaml","title":"Adding the First Command to <code>config_cod_check.yaml</code>","text":"<p>In the first step of this tutorial, we aim to introduce a command that outputs the number of structures with matching unit cell parameters and elements, as specified in a CIF file, to a JSON file within the work folder. Refer to the <code>simple_cod_module.py</code> script to understand the functionalities we're integrating. We will use the <code>cif_to_search_pars</code> function to generate search parameters and then employ <code>get_number_fitting_cod_entries</code> to find the count of matching structures.</p> <p>The initial setup, generated by <code>qcb init</code>, has already populated the top section of the YAML file. Your task now is to customize this section with our specific command details. Start by renaming <code>name</code> from the placeholder to <code>\"get_number_fitting_cod_entries\"</code> and change <code>implemented_as</code> from <code>\"cli\"</code> to <code>\"python_callable\"</code>.</p> <p>The command will require three parameters:</p> <ol> <li><code>input_cif_path</code> (string): Specifies which CIF file to use for checking similar structures.</li> <li><code>cellpar_deviation_perc</code> (float): Defines the maximum allowable deviation, in percentage, for unit cell parameters between COD structures and our target structure. The default value is set at 2.0%.</li> <li><code>listed_elements_only</code> (boolean): When set to True, the search will only include entries containing the exact elements listed in the <code>input_cif</code> file. If False, the search will accept entries with additional elements beyond those listed. By default, this is set to False.</li> </ol> <p>Here is how you should structure the command in the YAML file:</p> <pre><code>commands:\n  - name: \"get_number_fitting_cod_entries\"\n    implemented_as: \"python_callable\"\n    parameters:\n      - name: \"input_cif_path\"\n        type: \"str\"\n        default_value: None\n      - name: \"cellpar_deviation_perc\"\n        type: \"float\"\n        default_value: 2.0\n        required: false\n      - name: \"listed_elements_only\"\n        type: \"bool\"\n        default_value: false\n        required: false\n</code></pre>"},{"location":"tutorials/wrap_python_command/#specifying-required-cif-entries","title":"Specifying Required CIF Entries","text":"<p>Next, we must identify which CIF entries are essential for our command to function. Inspect the <code>cif_to_search_pars</code> function to determine these entries. If you're adding only one command, list these required entries directly. Ensure that <code>required_cif_entries:</code> aligns with the <code>parameters:</code> section for proper structure.</p> <pre><code>    required_cif_entries: [\n      \"_cell_length_a\", \"_cell_length_b\", \"_cell_length_c\",\n      \"_cell_angle_alpha\", \"_cell_angle_beta\", \"_cell_angle_gamma\",\n      \"_chemical_formula_sum\"\n    ]\n</code></pre> <p>For scenarios where certain CIF entries are beneficial but not mandatory, you could list them under <code>optional_cif_entries</code>. However, in this context, all listed entries are necessary, completing our current modifications to the YAML file.</p>"},{"location":"tutorials/wrap_python_command/#implementing-the-python-glue-code","title":"Implementing the Python Glue Code","text":"<p>Important Note: Currently, some functionality that will eventually be automated\u2014specifically, the registration of our application and commands in Python, as well as CIF file handling and conversion\u2014requires manual implementation. This step is temporary and is planned to be automated in future updates, following the developer alpha release. We're releasing this functionality now to provide a foundation for exploration and development.</p> <p>To begin, open the <code>configure_cod_check.py</code> file. Start by importing necessary functions from the Python base libraries as well as two different modules:</p> <pre><code>from pathlib import Path\nimport json\n\nfrom qcrboxtools.cif.cif2cif import cif_file_unified_yml_instr\nfrom simple_cod_module import cif_to_search_pars, get_number_fitting_cod_entries\n</code></pre> <p>The function <code>cif_file_unified_yml_instr</code> is designed to manage the CIF files' input and output, converting the CIF keywords used by QCrBox into those required by <code>simple_cod_module</code>. Additionally, we'll utilize two specific functions from <code>simple_cod_module</code> to execute our desired logic.</p> <p>Let's proceed to define the necessary Python functions within <code>configure_cod_check.py</code>:</p> <pre><code>YAML_PATH = \"./config_cod_check.yaml\"\n\ndef parse_input(input_cif_path, cellpar_deviation_perc, listed_elements_only):\n    # Convert string paths to Path objects for easier file handling\n    input_cif_path = Path(input_cif_path)\n\n    # Convert cellpar_deviation to the correct type and convert the given percentage to a decimal\n    cellpar_deviation = float(cellpar_deviation_perc) / 100.0\n\n    # Validate 'listed_elements_only' as a boolean value\n    if listed_elements_only.lower() not in (\"true\", \"false\"):\n        raise ValueError(\"'listed_elements_only' must be a boolean (true or false).\")\n\n    # Convert 'listed_elements_only' to a boolean\n    listed_elements_only = listed_elements_only.lower() == \"true\"\n\n    # Use the parent directory of the input CIF file as the working directory\n    work_folder = input_cif_path.parent\n\n    # Specify the path for the modified CIF file\n    work_cif_path = work_folder / \"work.cif\"\n\n    # Adjust the CIF file according to the requirements of 'simple_cod_module'\n    cif_file_unified_yml_instr(\n        input_cif_path=input_cif_path,\n        output_cif_path=work_cif_path,\n        yml_path=YAML_PATH,  # Referencing the edited YAML configuration\n        command=\"get_number_fitting_cod_entries\",  # Command name as specified in the YAML\n    )\n    return work_cif_path, cellpar_deviation, listed_elements_only\n\ndef qcb_get_number_fitting_cod_entries(input_cif_path, cellpar_deviation_perc, listed_elements_only):\n    # Transform input parameters from string to appropriate Python objects\n    work_cif_path, cellpar_deviation, listed_elements_only = parse_input(input_cif_path, cellpar_deviation_perc, listed_elements_only)\n\n    # Retrieve the number of matching entries\n    elements, cell_dict = cif_to_search_pars(work_cif_path)\n    n_entries = get_number_fitting_cod_entries(elements, cell_dict, cellpar_deviation, listed_elements_only)\n\n    # Save the output as a JSON file\n    with open(work_cif_path.parent / \"nentries.json\", \"w\", encoding=\"UTF-8\") as fobj:\n        json.dump({\"n_entries\": n_entries}, fobj)\n</code></pre> <p>The <code>parse_input</code> function will eventually be phased out as QCrBox plans will take over the input parameter handling and CIF file conversion making the explicit implementation obsolete.</p>"},{"location":"tutorials/wrap_python_command/#registering-the-python-function-as-a-qcrbox-command","title":"Registering the Python Function as a QCrBox Command","text":"<p>To integrate our command with QCrBox, it's necessary to register it within the system. Update the script's concluding section as follows:</p> <pre><code>client = QCrBoxRegistryClient()\napplication = client.register_application(\"COD Check\", version=\"0.0.1\")\n\n# Register the command with QCrBox, linking it to our Python function\napplication.register_python_callable(\"get_number_fitting_cod_entries\", qcb_get_number_fitting_cod_entries)\n\nclient.run()\n</code></pre> <p>QCrBox recognizes the parameter names from our Python function, using them directly as command parameters within the for the commands exposed by the QCrBox container.</p>"},{"location":"tutorials/wrap_python_command/#configuring-the-dockerfile","title":"Configuring the Dockerfile","text":"<p>The Dockerfile is preconfigured with some entries that we won't need. Here's a simplified explanation and modifications required:</p> <ol> <li> <p>Base Image Setup: The file begins with specifying the base image for the application. We use the <code>qcrbox/base-application</code> as our starting point, utilizing the latest version available.     <pre><code>ARG QCRBOX_DOCKER_TAG\nFROM qcrbox/base-application:${QCRBOX_DOCKER_TAG}\n</code></pre></p> </li> <li> <p>Environment Setup: Specifies using <code>/bin/bash</code> for running future commands.     <pre><code>SHELL [\"/bin/bash\", \"-c\"]\n</code></pre></p> </li> <li> <p>Inclusion of QCrBox settings files: The following lines will copy the <code>/configure_*.py</code> and the <code>/config_*.yaml</code> to our container, that we have modified to integrate our program with QCrBox.</p> <pre><code>COPY configure_cod_check.py ./\nCOPY config_cod_check.yaml ./\n</code></pre> </li> <li> <p>Module Inclusion: Ensure our module and its dependencies are included and properly set up in the container. For instance, add the Python module with:     <pre><code>COPY ./simple_cod_module.py ./\n</code></pre></p> </li> <li> <p>Dependency Management: Install necessary dependencies, like the <code>requests</code> module. Choose between using <code>micromamba</code> for Conda environments or <code>pip</code> for Python environments.</p> <ul> <li>For <code>micromamba</code>:     <pre><code>RUN micromamba install -n qcrbox requests --yes\n</code></pre>   If you have a large number of dependencies, working with a conda .yml file is more sensible.</li> <li>For <code>pip</code>:     <pre><code>RUN pip install requests\n</code></pre></li> </ul> </li> <li> <p>Delete unnecessary lines: The following two lines are not necessary for a Python application and should be deleted     ```Dockerfile     COPY sample_cmd.sh /opt/cod_check/bin/     ````</p> <p>```Dockerfile ENV PATH=\"$PATH:/opt/cod_check/bin/\" ````</p> </li> </ol>"},{"location":"tutorials/wrap_python_command/#building-the-container-with-the-first-command-exposed","title":"Building the container with the first command exposed","text":"<p>To create a QCrBox image for our application, we'll execute a specific build command using the application slug defined earlier. Open your terminal and input the following command to start the build process:</p> <pre><code>qcb build cod_check\n</code></pre> <p>Important Note: By default, <code>qcb build</code> without additional arguments performs a full rebuild of all dependencies to ensure everything is up-to-date. If you have recently completed a build and wish to save time, you can opt for the <code>--no-deps</code> argument. This option focuses solely on building the QCrBox image without updating the dependencies.</p> <p>After completing the build process, you can launch your newly created QCrBox image with the following command:</p> <pre><code>qcb up cod_check --no-rebuild-deps\n</code></pre> <p>This command starts the container without recompiling the image or its dependencies, assuming they were recently built. If you aim to update both dependencies and the image before launching, simply omit the <code>--no-rebuild-deps</code> flag. This ensures that your QCrBox image and all related components are fully up-to-date.</p>"},{"location":"tutorials/wrap_python_command/#build-a-function-to-load-in-a-structure-from-the-best-matching-unit-cell","title":"Build a function to load in a structure from the best matching unit cell","text":"<p>Our goal is to incorporate atomic parameters from the most compatible structure within the COD into our CIF file. This allows us to bypass the structure solution phase if matching information is readily available. To achieve this, we introduce a new command into the <code>config_cod_check.yaml</code> file. Append the following new command definition at the end of the file:</p> <pre><code>  - name: \"merge_closest_cod_entry\"\n    implemented_as: \"python_callable\"  # other options: \"python_callable\"\n    parameters:\n      - name: \"input_cif_path\"\n        type: \"str\"\n        default_value: None\n      - name: \"cellpar_deviation_perc\"\n        type: \"float\"\n        default_value: 2.0\n        required: false\n      - name: \"listed_elements_only\"\n        type: \"bool\"\n        default_value: false\n        required: false\n    required_cif_entries: [\n      \"_cell_length_a\", \"_cell_length_b\", \"_cell_length_c\", \"_cell_angle_alpha\",\n      \"_cell_angle_beta\", \"_cell_angle_gamma\", \"_chemical_formula_sum\"\n    ]\n</code></pre> <p>You might notice that our required cif entries are exactly the same, as they are used by the same function within the <code>simple_cod_module.py</code> file. This might be fine in this case, as the number of entries is rather low, However, we would like to only define the set of entries once. In QCrBox we can do that using cif_entry_sets. At the end of the file we create a new entry set for our commands:</p> <pre><code>cif_entry_sets:\n  - name: \"cell_elements\"\n    required: [\n      \"_cell_length_a\", \"_cell_length_b\", \"_cell_length_c\", \"_cell_angle_alpha\",\n      \"_cell_angle_beta\", \"_cell_angle_gamma\", \"_chemical_formula_sum\"\n    ]\n</code></pre> <p>Instead of writing the entries into the individual functions we now replace the <code>required_cif_entry</code> sections to have our command definition look like this:</p> <pre><code>  - name: \"merge_closest_cod_entry\"\n    implemented_as: \"python_callable\"  # other options: \"python_callable\"\n    parameters:\n      - name: \"input_cif_path\"\n        type: \"str\"\n        default_value: None\n      - name: \"cellpar_deviation_perc\"\n        type: \"float\"\n        default_value: 2.0\n        required: false\n      - name: \"listed_elements_only\"\n        type: \"bool\"\n        default_value: false\n        required: false\n    required_cif_entry_sets: [\"cell_elements\"]\n</code></pre> <p>Try to update the definition of the <code>get_number_fitting_cod_entries</code> on your own. Note that you can have multiple cif entry sets. You can also combine entry sets with individual keywords to mix and match whatever your commands need.</p>"},{"location":"tutorials/wrap_python_command/#developing-the-python-glue-code-for-our-merge-command","title":"Developing the Python Glue Code for Our Merge Command.","text":"<p>We will now modify the <code>configure_cod_check.py</code> file to add the new functionality. We will use more functionality from both QCrBoxtools and our COD module. Our input section should now look like this:</p> <pre><code>from qcrbox.registry.client import QCrBoxRegistryClient\nfrom qcrboxtools.cif.cif2cif import (\n    cif_file_unified_yml_instr,\n    cif_file_unify_split,\n)\nfrom qcrboxtools.cif.merge import replace_structure_from_cif\n\nfrom simple_cod_module import (\n    cif_to_search_pars,\n    get_number_fitting_cod_entries,\n    get_fitting_cod_entries,\n    download_cod_cif,\n)\n</code></pre> <p>The <code>cif_file_unify_split</code> is the counterpart of the first function from cif2cif. We can use it to convert a non-unified cif to the unified set of entries. The <code>replace_structure_from_cif</code> function will do the actual replacement. The function <code>get_fitting_cod_entries</code> returns a list of dictionaries of cod entries, sorted by the sum of squared differences in the unit cell parameters. Finally, <code>download_cod_cif</code> can be used to download an entry from the cod.</p> <p>We can now implement our function</p> <pre><code>def merge_closest_cod_entry(input_cif_path, cellpar_deviation_perc, listed_elements_only):\n    # cast the input parameters from strings to python objects\n    work_cif_path, cellpar_deviation, listed_elements_only = parse_input(\n        input_cif_path, cellpar_deviation_perc, listed_elements_only\n    )\n\n    # get the list of fitting entries\n    elements, cell_dict = cif_to_search_pars(work_cif_path)\n    entry_lst = get_fitting_cod_entries(elements, cell_dict, cellpar_deviation, listed_elements_only)\n\n    # if no fitting entries found, raise an error\n    if len(entry_lst) == 0:\n        raise ValueError(\"No fitting entries found\")\n\n    # download the cif file of the most fitting entry\n    cod_cif_path = work_cif_path.parent / \"cod.cif\"\n    download_cod_cif(entry_lst[0][\"file\"], cod_cif_path)\n\n    # convert to unified format\n    unified_cod_path = work_cif_path.parent / \"cod_unified.cif\"\n    cif_file_unify_split(\n        cod_cif_path,\n        unified_cod_path,\n        custom_categories=[\"cod\", \"iucr\", \"olex2\", \"shelx\"],\n    )\n\n    # replace structure from input cif with the one from cod cif\n    replace_structure_from_cif(input_cif_path, 0, unified_cod_path, 0, work_cif_path.parent / \"output.cif\")\n</code></pre> <p>And finally we register that function with QCrBox by adding</p> <pre><code>application.register_python_callable(\"merge_closest_cod_entry\", merge_closest_cod_entry)\n</code></pre> <p>right before <code>client.run()</code></p>"},{"location":"tutorials/wrap_python_command/#rebuilding-and-restarting-the-container","title":"Rebuilding and Restarting the Container","text":"<p>If you have not done so you can shut down QCrBox by typing <code>qcb down</code>. You can now restart and rebuild the container by typing. Rebuilding without dependencies might be faster if you have just rebuid everything.</p> <pre><code>qcb up cod_check\n</code></pre>"},{"location":"tutorials/wrap_python_command/#conclusion-and-final-remarks","title":"Conclusion and final remarks","text":"<p>We have now exposed two commands in QCrbox from a Python module. One that only analyses a cif file to produce some output, and another one that works from an input cif file to an output cif. If you want to interact with what you have build, a ipython notebook you can put into the examples folder can be found here.</p> <p>For more examples you might consider looking into the already implemented programs in <code>services/applications</code>. If this tutorial is unclear at any point please raise an issue on Github with the specific problem that you ran into.</p>"},{"location":"tutorials/examples/example_crystal_explorer/","title":"Interacting with CrystalExplorer","text":"In\u00a0[\u00a0]: Copied! <pre>import shutil\n\nfrom qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper\n</pre> import shutil  from qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper <p>We create a path to run our Crystal Explorer example and get our paths from our own computer's filesystem and the internal filesystem of the QCrBox containers.</p> <p>Using the dotenv package makes things more convenient as we can read the environment variables from the .env.dev file in the QCrBox directory. If you want to run with python core packages only, use the <code>__init__</code> method instead by defining the path to the shared directory explicitely in <code>path_to_shared_dir</code> and replacing the next four lines with:</p> <pre>pathhelper = QCrBoxPathHelper(\n    path_to_shared_dir,\n    'examples_crystal_explorer'\n)\n</pre> In\u00a0[\u00a0]: Copied! <pre>pathhelper = QCrBoxPathHelper.from_dotenv(\n    '.env.dev',\n    'examples_crystal_explorer'\n)\n\npath_local = pathhelper.local_path\npath_qcrbox = pathhelper.qcrbox_path\n</pre> pathhelper = QCrBoxPathHelper.from_dotenv(     '.env.dev',     'examples_crystal_explorer' )  path_local = pathhelper.local_path path_qcrbox = pathhelper.qcrbox_path In\u00a0[\u00a0]: Copied! <pre>qcrbox = QCrBoxWrapper('127.0.0.1', 11000)\n</pre> qcrbox = QCrBoxWrapper('127.0.0.1', 11000) <p>We should see `Crystalexplorer in our application_dict and should put it into a variable.</p> In\u00a0[\u00a0]: Copied! <pre>qcrbox.application_dict\n</pre> qcrbox.application_dict  In\u00a0[\u00a0]: Copied! <pre>crystal_explorer = qcrbox.application_dict['CrystalExplorer']\n</pre> crystal_explorer = qcrbox.application_dict['CrystalExplorer']  In\u00a0[\u00a0]: Copied! <pre>shutil.copy('./input_files/input.cif', path_local / 'input.cif')\n\ncalc = crystal_explorer.interactive(\n    input_cif_path=path_qcrbox / 'input.cif'\n)\ncalc.status\n</pre> shutil.copy('./input_files/input.cif', path_local / 'input.cif')  calc = crystal_explorer.interactive(     input_cif_path=path_qcrbox / 'input.cif' ) calc.status In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/examples/example_crystal_explorer/#run-crystal-explorer-from-qcrbox","title":"Run Crystal Explorer from QCrBox\u00b6","text":""},{"location":"tutorials/examples/example_crystal_explorer/#connecting-to-qcrbox","title":"Connecting to QCrBox\u00b6","text":"<p>We can connect to the QCrBox Inventory via python after we have started everything with <code>qcb up</code>. Sometimes the server takes a while so you might need to retry if it initially refuses connection. This should not take more than 30 seconds after your console output says that everything has started.</p>"},{"location":"tutorials/examples/example_crystal_explorer/#running-the-crystal-explorer-gui-in-qcrbox","title":"Running the Crystal Explorer GUI in QCrBox\u00b6","text":"<p>We can now access the GUI of Crystal Explorer within the container. To run the command needs a unified cif, which is then internally converted into the format CrystalExplorer needs. For more read the Olex2 Example Notebook (TODO Write and link a more complete explanation in docs).</p> <p>Once we run the <code>interactive</code> command, two things happen: Firstly, a new browser window with the GUI opens up. Secondly, you should see an input prompt in your execution engine for this notebook. (In Jupyter this should be at the end of the cell, in VSCode it is at the top). By pressing enter within this prompt we tell QCrBox that we are done. There is no back conversion, as we do not expect Crystal Explorer to modify the cif file. Note that this input prompt is a stopgap for an actual UI, so this feels a bit clunky at the moment.</p>"},{"location":"tutorials/examples/example_eval/","title":"Interacting with Eval14/15","text":"In\u00a0[2]: Copied! <pre>import zipfile\nimport urllib.request\nfrom pathlib import Path\n\nfrom qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper\n\nexample_frames = Path('./input_files/Ylid_OD_Images.zip')\nexample_input_files = Path('./input_files/eval_input.zip')\n\nfor zip_path in (example_frames, example_input_files):\n    if not zip_path.exists():\n        url = f'https://github.com/QCrBox/QCrBoxExamples/raw/main/Eval/{zip_path.name}'\n        urllib.request.urlretrieve(url, zip_path)\n</pre> import zipfile import urllib.request from pathlib import Path  from qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper  example_frames = Path('./input_files/Ylid_OD_Images.zip') example_input_files = Path('./input_files/eval_input.zip')  for zip_path in (example_frames, example_input_files):     if not zip_path.exists():         url = f'https://github.com/QCrBox/QCrBoxExamples/raw/main/Eval/{zip_path.name}'         urllib.request.urlretrieve(url, zip_path)  <p>We create an example folder to try out the Eval functionality.</p> <p>Using the dotenv package makes things more convenient as we can read the environment variables from the .env.dev file in the QCrBox directory. If you want to run with python core packages only, use the <code>__init__</code> method instead by defining the path to the shared directory explicitely in <code>path_to_shared_dir</code> and replacing the next four lines with:</p> <pre>pathhelper = QCrBoxPathHelper(\n    path_to_shared_dir,\n    'examples_eval'\n)\n</pre> In\u00a0[\u00a0]: Copied! <pre>pathhelper = QCrBoxPathHelper.from_dotenv(\n    '.env.dev',\n    'examples_eval'\n)\n\npath_local = pathhelper.local_path\npath_qcrbox = pathhelper.qcrbox_path\n\nframes_zip = './input_files/Ylid_OD_Images.zip'\n</pre> pathhelper = QCrBoxPathHelper.from_dotenv(     '.env.dev',     'examples_eval' )  path_local = pathhelper.local_path path_qcrbox = pathhelper.qcrbox_path  frames_zip = './input_files/Ylid_OD_Images.zip'  In\u00a0[\u00a0]: Copied! <pre>qcrbox = QCrBoxWrapper('127.0.0.1', 11000)\n</pre> qcrbox = QCrBoxWrapper('127.0.0.1', 11000) In\u00a0[\u00a0]: Copied! <pre>qcrbox.application_dict\n</pre> qcrbox.application_dict <p>Check that Eval1X is available in the application dict you just evaluated and then select it in the next cell.</p> In\u00a0[\u00a0]: Copied! <pre>eval1x = qcrbox.application_dict['Eval1X']\n</pre> eval1x = qcrbox.application_dict['Eval1X']  <p>As always we can get the list of available commands using pythons buildin help function.</p> In\u00a0[\u00a0]: Copied! <pre>help(eval1x)\n</pre> help(eval1x) In\u00a0[\u00a0]: Copied! <pre># create a new folder for this example\nfolder_interact = path_local / 'run_interactive'\nfolder_interact.mkdir(exist_ok=True)\n\nwith zipfile.ZipFile(frames_zip, 'r') as zip_obj:\n    zip_obj.extractall(folder_interact)\n</pre> # create a new folder for this example folder_interact = path_local / 'run_interactive' folder_interact.mkdir(exist_ok=True)  with zipfile.ZipFile(frames_zip, 'r') as zip_obj:     zip_obj.extractall(folder_interact) <p>Now let us start an interactive session. Once we run the <code>interactive</code> command, two things happen: Firstly, a new browser window with the opens up, where a command line interface opens in the folder of your choice. Secondly, you should see an input prompt in your execution engine for this notebook. (In Jupyter this should be at the end of the cell, in VSCode it is at the top). By pressing enter within this prompt we tell QCrBox that we are done following the example. Subsequently QCrBox will try to run a few programs to produce a cif file with the output via Evals output to SADABS' .sad format. There is no cif file at the beginning of an integration. As such there cannot be an <code>input_cif_path</code>. Instead we need to pass the folder where we want to work that contains the frames. You can now try to follow along the the thaumatin example from the Eval website using the Ylid frames.</p> <p>Here are the changes to the example:</p> In\u00a0[\u00a0]: Copied! <pre>calc1 = eval1x.interactive(path_qcrbox / 'run_interactive')\n\n# Do not forget to press &lt;enter&gt; in the input prompt at the end!\n</pre> calc1 = eval1x.interactive(path_qcrbox / 'run_interactive')  # Do not forget to press  in the input prompt at the end!  In\u00a0[\u00a0]: Copied! <pre>use_files_from_zip = False  # Change to True to use settings files from zip\n\n# create a new folder for this example\nfolder_integrate = path_local / 'run_integrate'\nfolder_integrate.mkdir(exist_ok=True)\n\nwith zipfile.ZipFile(frames_zip, 'r') as zip_obj:\n    zip_obj.extractall(folder_integrate)\n\nif use_files_from_zip:\n    with zipfile.ZipFile('./input_files/eval_input.zip', 'r') as zip_obj:\n        zip_obj.extractall(folder_integrate)\n    source_folder = path_qcrbox / 'run_integrate'\nelse:\n    source_folder = path_qcrbox / 'run_interactive'\n</pre> use_files_from_zip = False  # Change to True to use settings files from zip  # create a new folder for this example folder_integrate = path_local / 'run_integrate' folder_integrate.mkdir(exist_ok=True)  with zipfile.ZipFile(frames_zip, 'r') as zip_obj:     zip_obj.extractall(folder_integrate)  if use_files_from_zip:     with zipfile.ZipFile('./input_files/eval_input.zip', 'r') as zip_obj:         zip_obj.extractall(folder_integrate)     source_folder = path_qcrbox / 'run_integrate' else:     source_folder = path_qcrbox / 'run_interactive' <p>We can now start the integration using the output files from either the zip archive or the interactive session. You might notice that we pass a path to a cif file as the <code>rmat_file_path</code> if it contains the required entries. An rmat file will work as well. The integration will probably take a bit of time. You can follow the progress within the <code>ic</code> folder.</p> In\u00a0[\u00a0]: Copied! <pre>calc2 = eval1x.integrate(\n    work_folder=path_qcrbox / 'run_integrate',\n    rmat_file_path=source_folder / 'output.cif',\n    beamstop_file_path=source_folder / 'beamstop.vic',\n    detalign_file_path=source_folder / 'detalign.vic',\n    maximum_res=0.79,\n    minimum_res=50.0,\n    box_size=1.2,\n    box_depth=5,\n    maximum_duration=5.0,\n    min_refln_in_box=1000,\n    pic_dir=source_folder / 'ic'\n)\n\ncalc2.wait_while_running(1.0)\n</pre> calc2 = eval1x.integrate(     work_folder=path_qcrbox / 'run_integrate',     rmat_file_path=source_folder / 'output.cif',     beamstop_file_path=source_folder / 'beamstop.vic',     detalign_file_path=source_folder / 'detalign.vic',     maximum_res=0.79,     minimum_res=50.0,     box_size=1.2,     box_depth=5,     maximum_duration=5.0,     min_refln_in_box=1000,     pic_dir=source_folder / 'ic' )  calc2.wait_while_running(1.0) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/examples/example_eval/#running-eval1415-in-a-qcrbox-docker-container","title":"Running Eval14/15 in a QCrBox Docker container\u00b6","text":"<p>Eval15 is a program to integrate crystallographic frames and evaluate the intensities of the reflections. The executable must be obtained separately from the Eval website.</p> <p>We start by downloading some example files.</p>"},{"location":"tutorials/examples/example_eval/#connecting-to-qcrbox","title":"Connecting to QCrBox\u00b6","text":"<p>We can connect to the QCrBox Inventory via python after we have started everything with qcb up. Sometimes the server takes a while so you might need to retry if it initially refuses connection. This should not take more than 30 seconds after your console output says that everything has started.</p>"},{"location":"tutorials/examples/example_eval/#starting-an-interactive-session","title":"Starting an interactive session.\u00b6","text":"<p>Currently the implementation of eval within QCrBox assumes that you first integrate your frames interactively following along the thaumatin example from the Eval website.</p> <p>A set of frames to use as example is included in <code>input_files/Ylid_OD_Images.zip</code>. So let us create a new folder and unpack the images to that folder.</p>"},{"location":"tutorials/examples/example_eval/#proteinsetup","title":"proteinsetup\u00b6","text":"<p>The unit cell of Ylid is about a=5 Ang, b=8 Ang, c=18 Ang, change the maximum volume to 1500 Ang.</p>"},{"location":"tutorials/examples/example_eval/#renameimages","title":"renameimages\u00b6","text":"<p>The images are already renamed so skip</p>"},{"location":"tutorials/examples/example_eval/#scancheck","title":"scancheck\u00b6","text":"<p>You need to run <code>scandb</code> first</p>"},{"location":"tutorials/examples/example_eval/#view","title":"view\u00b6","text":"<p>Do not change the detectoroffset from the values in the frames. (But export a detalign.vic). The beamstop settings are</p> <ul> <li><code>beamstop 0.0 -1.3</code></li> <li><code>beamstopwidth 1.5</code></li> <li><code>beamstopdiameter 4</code></li> <li><code>beamstopangle 1</code></li> </ul> <p>Also set <code>resomax 0.79</code>, the number of peaks on a frame is 10</p>"},{"location":"tutorials/examples/example_eval/#buildsearch-buildsearch2","title":"buildsearch / buildsearch=2\u00b6","text":"<p>Be sure to set the maximum resolution and the number of peaks per frame correctly</p>"},{"location":"tutorials/examples/example_eval/#buildeval15","title":"buildeval15\u00b6","text":"<p>Use focus type mirror and no polarisation</p>"},{"location":"tutorials/examples/example_eval/#shellscript-2","title":"shellscript-2\u00b6","text":"<p>Use <code>eval15all</code> instead by typing <code>eval15all</code> into the commandline</p>"},{"location":"tutorials/examples/example_eval/#any","title":"any\u00b6","text":"<p>You do not need to set the pointgroup with pg</p>"},{"location":"tutorials/examples/example_eval/#sadabs-and-shellscript-3","title":"sadabs and shellscript-3\u00b6","text":"<p>sadabs is not independent of eval and therefore not available within the container.</p>"},{"location":"tutorials/examples/example_eval/#running-an-integration-with-slightly-changed-parameters","title":"Running an integration with slightly changed parameters\u00b6","text":"<p>There is a basic way to run parts the data processing pipeline from the input files of an interactive session. The number of necessary files might be reduced in the future. This allows to reprocess frames that have been subject to Eval15 before. We can pull the necessary files from our interactive session from before to rerun the integration with a different resolution. Alternatively you can use the files in the <code>./input_files/eval_input.zip</code>. Let us create a folder again. You can set <code>use_files_from_zip</code> to <code>True</code> to use these.</p>"},{"location":"tutorials/examples/example_olex2/","title":"Interacting with Olex2","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport shutil\n\nfrom qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper\n</pre> import os import shutil  from qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper <p>We create a path to run our Olex2 examples and get our paths from our own computer's filesystem and the internal filesystem of the QCrBox containers.</p> <p>Using the dotenv package makes things more convenient as we can read the environment variables from the .env.dev file in the QCrBox directory. If you want to run with python core packages only, use the <code>__init__</code> method instead by defining the path to the shared directory explicitely in <code>path_to_shared_dir</code> and replacing the next four lines with:</p> <pre>pathhelper = QCrBoxPathHelper(\n    path_to_shared_dir,\n    'examples_olex2'\n)\n</pre> In\u00a0[\u00a0]: Copied! <pre>pathhelper = QCrBoxPathHelper.from_dotenv(\n    '.env.dev',\n    'examples_olex2'\n)\n</pre> pathhelper = QCrBoxPathHelper.from_dotenv(     '.env.dev',     'examples_olex2' ) <p>We now have two python pathlib objects we can use to make the reference to our pathes much easier. We have also created an examples_olex2 folder we will use to work for this notebook.</p> In\u00a0[\u00a0]: Copied! <pre>path_local = pathhelper.local_path\npath_qcrbox = pathhelper.qcrbox_path\n</pre> path_local = pathhelper.local_path path_qcrbox = pathhelper.qcrbox_path <p>Let us first connect to the QCrBox. Make sure that you have actually started up the container with <code>qcb up</code> in the terminal. Sometimes it can take a while for the Server to come online, so you might need to retry a few times. Unfortunately we have to pass the information, which commands are interactive commannds and where we can access them via browser. This is something that should be available from the containers in the future but unfortunately is not at the moment.</p> In\u00a0[\u00a0]: Copied! <pre>qcrbox = QCrBoxWrapper('127.0.0.1', 11000)\n</pre> qcrbox = QCrBoxWrapper('127.0.0.1', 11000) <p>We can now see what applications are currently available and how we can access them. Olex2 (Linux) should show up here and therefore we select it in the new cell.</p> In\u00a0[\u00a0]: Copied! <pre>qcrbox.application_dict\n</pre> qcrbox.application_dict In\u00a0[\u00a0]: Copied! <pre>olex2 = qcrbox.application_dict['Olex2 (Linux)']\n</pre> olex2 = qcrbox.application_dict['Olex2 (Linux)'] <p>Using the python buildin help function we can see which commands are available for the given container.</p> In\u00a0[\u00a0]: Copied! <pre>help(olex2)\n</pre> help(olex2) <p>We can now run our first command. QCrBox works with a subsect of cif entries, which will be called unified cif entries in this explanation. The subset are the base cif entries in the current cif dictionaries (as of March 2024). The conversion of these entries into a format the individual programs can understand is programmed into the commands themselves. This way the aliases of the cif format do not need to be taken into account by the developers of the software. If you want to create such a cif file from any cif, look at the <code>qcrboxtools.to_unified_cif function</code> or the QCrBoxTools library.</p> In\u00a0[\u00a0]: Copied! <pre>folder_iam = path_local / 'run_refine_iam'\nfolder_iam.mkdir(exist_ok=True)\n\nshutil.copy('./input_files/input.cif', folder_iam / 'input.cif')\n\ncalc = olex2.refine_iam(\n    input_cif_path=path_qcrbox / 'run_refine_iam' / 'input.cif',\n    ls_cycles='20',\n    weight_cycles='5'\n)\n\ncalc.wait_while_running(1.0)\n</pre> folder_iam = path_local / 'run_refine_iam' folder_iam.mkdir(exist_ok=True)  shutil.copy('./input_files/input.cif', folder_iam / 'input.cif')  calc = olex2.refine_iam(     input_cif_path=path_qcrbox / 'run_refine_iam' / 'input.cif',     ls_cycles='20',     weight_cycles='5' )  calc.wait_while_running(1.0) <p>What will happen under the hood is that qcrbox will generate a <code>work.cif</code> that has all the entries in aliases Olex2 understands. It will then run the refinement. Afterwards it will create a new cif that uses unified keywords again called <code>output.cif</code>.</p> <p>Finally we can have a look at that calculation object. It gives updated information about the calculation and in many cases information why a calculation might have failed. Fortunately, our status should now show 'completed', which means everything went as intended.</p> In\u00a0[\u00a0]: Copied! <pre>calc.status\n</pre> calc.status <p>If you have a failure in the execution of a command it is always a good idea to look into the log of your docker container. The way Olex2 is executed here gives an additional source of information: <code>task_*.log</code> files. Have a look in your folder, where several of these should now be located.</p> In\u00a0[\u00a0]: Copied! <pre>folder_tsc = path_local / 'run_refine_tsc'\nfolder_tsc.mkdir(exist_ok=True)\n\nshutil.copy('./input_files/input.cif', folder_tsc / 'input.cif')\nshutil.copy('./input_files/example.tscb', folder_tsc / 'example.tscb')\n\ncalc = olex2.refine_tsc(\n    input_cif_path=path_qcrbox / 'run_refine_tsc' / 'input.cif',\n    tsc_path=path_qcrbox / 'run_refine_tsc' / 'example.tscb',\n    ls_cycles='20',\n    weight_cycles='5'\n)\n\ncalc.wait_while_running(1.0)\n</pre> folder_tsc = path_local / 'run_refine_tsc' folder_tsc.mkdir(exist_ok=True)  shutil.copy('./input_files/input.cif', folder_tsc / 'input.cif') shutil.copy('./input_files/example.tscb', folder_tsc / 'example.tscb')  calc = olex2.refine_tsc(     input_cif_path=path_qcrbox / 'run_refine_tsc' / 'input.cif',     tsc_path=path_qcrbox / 'run_refine_tsc' / 'example.tscb',     ls_cycles='20',     weight_cycles='5' )  calc.wait_while_running(1.0)  <p>If you go to the folder, you'll see that there are again our cif files. The task_*.log file with the highest number should contain the progress of your refinement. If you want to, you can compare the numbers to what was obtained by the IAM refinement.</p> In\u00a0[\u00a0]: Copied! <pre>folder_cmd = path_local / 'run_cmd_file'\nfolder_cmd.mkdir(exist_ok=True)\n\nshutil.copy('./input_files/input.cif', folder_cmd / 'input.cif');\n</pre> folder_cmd = path_local / 'run_cmd_file' folder_cmd.mkdir(exist_ok=True)  shutil.copy('./input_files/input.cif', folder_cmd / 'input.cif'); <p>Now we create a text file that includes the commands we want to execute as lines. Let's create a <code>structure.xyz</code> file from our cif.</p> In\u00a0[\u00a0]: Copied! <pre>commands = ['file structure.xyz']\n\ncommand_file = folder_cmd / 'cmd.input'\ncommand_file.write_text('\\n'.join(commands))\n\ncalc = olex2.run_cmds_file(\n    input_cif_path=path_qcrbox / 'run_cmd_file' / 'input.cif',\n    cmd_file_path=path_qcrbox / 'run_cmd_file' / 'cmd.input',\n)\n\ncalc.wait_while_running(0.5)\n</pre> commands = ['file structure.xyz']  command_file = folder_cmd / 'cmd.input' command_file.write_text('\\n'.join(commands))  calc = olex2.run_cmds_file(     input_cif_path=path_qcrbox / 'run_cmd_file' / 'input.cif',     cmd_file_path=path_qcrbox / 'run_cmd_file' / 'cmd.input', )  calc.wait_while_running(0.5)  <p>You might see that there is no <code>output.cif</code> file in the folder. The <code>output.cif</code> is only generated if the work.cif has been changed during our operations. If you want to, you can use a command like 'refine 10' to actually change the <code>work.cif</code> and check that the <code>output.cif</code> file is generated in this case.</p> In\u00a0[\u00a0]: Copied! <pre>folder_interactive = path_local / 'run_interactive'\nfolder_interactive.mkdir(exist_ok=True)\n\ninput_interactive = folder_interactive / 'input.cif'\nshutil.copy('./input_files/input.cif', input_interactive)\n\ncalc = olex2.interactive(\n    input_cif_path=path_qcrbox / 'run_interactive' / 'input.cif'\n)\ncalc.status\n</pre> folder_interactive = path_local / 'run_interactive' folder_interactive.mkdir(exist_ok=True)  input_interactive = folder_interactive / 'input.cif' shutil.copy('./input_files/input.cif', input_interactive)  calc = olex2.interactive(     input_cif_path=path_qcrbox / 'run_interactive' / 'input.cif' ) calc.status"},{"location":"tutorials/examples/example_olex2/#example-notebook-illustrating-the-use-of-olex2-in-qcrbox","title":"Example Notebook illustrating the use of Olex2 in QCrBox\u00b6","text":""},{"location":"tutorials/examples/example_olex2/#running-an-iam-refinement","title":"Running an IAM refinement\u00b6","text":"<p>For the time being we copy our example cif file into the folder we will work in. We can then use the <code>olex2.refine_iam</code> function to do a refinement against spherical atomic form factors. Notice that all our python code uses the local path, while the function runs in the container itself and therefore needs a path relative to the container (derived from <code>path_qcrbox</code>).</p> <p>Finally, all functions in containers are executed asynchronously and non-blocking in our script. In order to wait until the function has been executed we can use the <code>wait_while_running</code> function of the returned calculated object</p>"},{"location":"tutorials/examples/example_olex2/#running-a-refinement-with-a-tsc-file","title":"Running a refinement with a tsc file.\u00b6","text":"<p>There is also exposed functionality to run the refinement with a <code>tsc(b)</code> file. Let's do just that</p>"},{"location":"tutorials/examples/example_olex2/#running-arbitrary-olex-console-commands","title":"Running arbitrary Olex console commands.\u00b6","text":"<p>Finally, there is the option to run arbitrary olex2 console commands from a file. Let us put everything in a folder first</p>"},{"location":"tutorials/examples/example_olex2/#running-the-olex2-gui-from-qcrbox","title":"Running the Olex2 GUI from QCrBox\u00b6","text":"<p>While the other commands are run non-interactively, we can also run the Olex2 GUI from QCrBox. The exposed command for this purpose is called <code>interactive</code>. However, we do face a problem. Olex2 works and outputs other cif entries than unified ones, but we only want to convert once we are done with whatever we want to to in the GUI.</p> <p>Once we run the <code>interactive</code> command, two things happen: Firstly, a new browser window with the GUI opens up. Secondly, you should see an input prompt in your execution engine for this notebook. (In Jupyter this should be at the end of the cell, in VSCode it is at the top). By pressing enter within this prompt we tell QCrBox that we are done and the newest cif in the folder is supposed to be converted. Note that this is a stopgap for an actual UI, so this feels a bit clunky at the moment.</p> <p>Once you have done something in the UI and have pressed enter you should see an <code>output.cif</code> in the <code>run_interactive</code> folder.</p>"},{"location":"tutorials/examples/example_olex2/#final-remarks","title":"Final Remarks\u00b6","text":"<p>This concludes this notebook explaining how to interact with the Olex2 container. You might realise that there are to functions <code>to_params__interactive</code> and <code>redo__interactive</code>. These will be explained in the developer documentation.</p>"},{"location":"tutorials/examples/example_olex2.toparams_stub/","title":"Example olex2.toparams stub","text":"In\u00a0[\u00a0]: Copied! <pre>params_pathhelper = QCrBoxPathHelper(\n    local_path='D:/QCrBox/QCrBox/shared_files',\n    base_dir='params_olex2'\n)\n\nparams_path_local = params_pathhelper.local_path\nparams_path_container = params_pathhelper.qcrbox_path\n\nparams_path_local.mkdir(exist_ok=True)\n</pre> params_pathhelper = QCrBoxPathHelper(     local_path='D:/QCrBox/QCrBox/shared_files',     base_dir='params_olex2' )  params_path_local = params_pathhelper.local_path params_path_container = params_pathhelper.qcrbox_path  params_path_local.mkdir(exist_ok=True) In\u00a0[\u00a0]: Copied! <pre>calc = olex2.toparams__interactive(\n    work_folder = '/mnt/qcrbox/shared_files/work_olex2',\n    par_json= params_path_container / 'parameters.json',\n    par_folder=params_path_container\n)\ncalc.wait_while_running(1.0)\n</pre> calc = olex2.toparams__interactive(     work_folder = '/mnt/qcrbox/shared_files/work_olex2',     par_json= params_path_container / 'parameters.json',     par_folder=params_path_container ) calc.wait_while_running(1.0) In\u00a0[\u00a0]: Copied! <pre>calc.status\n</pre> calc.status In\u00a0[\u00a0]: Copied! <pre>redo_pathhelper = QCrBoxPathHelper(\n    local_path='D:/QCrBox/QCrBox/shared_files',\n    base_dir='redo_olex2'\n)\n\nredo_path_local = redo_pathhelper.local_path\nredo_path_container = redo_pathhelper.qcrbox_path\n\nredo_path_local.mkdir(exist_ok=True)\n</pre> redo_pathhelper = QCrBoxPathHelper(     local_path='D:/QCrBox/QCrBox/shared_files',     base_dir='redo_olex2' )  redo_path_local = redo_pathhelper.local_path redo_path_container = redo_pathhelper.qcrbox_path  redo_path_local.mkdir(exist_ok=True)  In\u00a0[\u00a0]: Copied! <pre>calc = olex2.redo__interactive(\n    input_cif=redo_path_container / 'input.cif',\n    work_folder=redo_path_container,\n    par_json=params_path_container / 'parameters.json',\n    par_folder=params_path_container\n)\n</pre>  calc = olex2.redo__interactive(     input_cif=redo_path_container / 'input.cif',     work_folder=redo_path_container,     par_json=params_path_container / 'parameters.json',     par_folder=params_path_container ) In\u00a0[\u00a0]: Copied! <pre>calc.wait_while_running(1.0)\n</pre> calc.wait_while_running(1.0) In\u00a0[\u00a0]: Copied! <pre>calc.status\n</pre> calc.status In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/examples/example_olex2.toparams_stub/#refining-against-the-result-from-an-interactive-run-with-new-data","title":"Refining against the result from an interactive run with new data.\u00b6","text":""},{"location":"tutorials/examples/example_qcrboxtools/","title":"Interacting with QCrBoxTools","text":"In\u00a0[\u00a0]: Copied! <pre>import shutil\n\nfrom qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper\n</pre> import shutil  from qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper   <p>We create an example folder to try out this functionality.</p> <p>Using the dotenv package makes things more convenient as we can read the environment variables from the .env.dev file in the QCrBox directory. If you want to run with python core packages only, use the <code>__init__</code> method instead by defining the path to the shared directory explicitely in <code>path_to_shared_dir</code> and replacing the next four lines with:</p> <pre>pathhelper = QCrBoxPathHelper(\n    path_to_shared_dir,\n    'examples_qcrboxtools'\n)\n</pre> In\u00a0[\u00a0]: Copied! <pre>pathhelper = QCrBoxPathHelper.from_dotenv(\n    '.env.dev',\n    'examples_qcrboxtools'\n)\n\npath_local = pathhelper.local_path\npath_qcrbox = pathhelper.qcrbox_path\n</pre> pathhelper = QCrBoxPathHelper.from_dotenv(     '.env.dev',     'examples_qcrboxtools' )  path_local = pathhelper.local_path path_qcrbox = pathhelper.qcrbox_path In\u00a0[\u00a0]: Copied! <pre>qcrbox = QCrBoxWrapper('127.0.0.1', 11000)\n</pre> qcrbox = QCrBoxWrapper('127.0.0.1', 11000) In\u00a0[\u00a0]: Copied! <pre>qcrboxtools = qcrbox.application_dict['QCrBoxTools']\n</pre> qcrboxtools = qcrbox.application_dict['QCrBoxTools'] In\u00a0[\u00a0]: Copied! <pre>help(qcrboxtools)\n</pre> help(qcrboxtools) In\u00a0[\u00a0]: Copied! <pre># create a new folder for this example\nfolder_unify = path_local / 'run_unify_cif'\nfolder_unify.mkdir(exist_ok=True)\n\n# copy file\nshutil.copy('./input_files/non_unified_kws.cif', folder_unify / 'non_unified_kws.cif')\n\n# start command\ncalc = qcrboxtools.to_unified_cif(\n    input_cif_path=path_qcrbox / 'run_unify_cif' / 'non_unified_kws.cif',\n    output_cif_path=path_qcrbox / 'run_unify_cif' / 'output.cif',\n    custom_category_list='iucr olex shelx'\n)\n\n# wait for command to finish\nprint(calc.status)\ncalc.wait_while_running(0.2)\nprint(calc.status)\n</pre> # create a new folder for this example folder_unify = path_local / 'run_unify_cif' folder_unify.mkdir(exist_ok=True)  # copy file shutil.copy('./input_files/non_unified_kws.cif', folder_unify / 'non_unified_kws.cif')  # start command calc = qcrboxtools.to_unified_cif(     input_cif_path=path_qcrbox / 'run_unify_cif' / 'non_unified_kws.cif',     output_cif_path=path_qcrbox / 'run_unify_cif' / 'output.cif',     custom_category_list='iucr olex shelx' )  # wait for command to finish print(calc.status) calc.wait_while_running(0.2) print(calc.status) <p>Feel free to check the <code>output.cif</code>. You can now used this file to start any other functionality within QCrBox.</p> In\u00a0[\u00a0]: Copied! <pre># create a new folder for this example\nfolder_iso2aniso = path_local / 'run_iso2aniso'\nfolder_iso2aniso.mkdir(exist_ok=True)\n\n# copy files\nshutil.copy('./input_files/iso2aniso.cif', folder_iso2aniso / 'iso2aniso.cif')\n\n# run command\ncalc2 = qcrboxtools.iso2aniso(\n    cif_path=path_qcrbox / 'run_iso2aniso' / 'iso2aniso.cif',\n    cif_dataset='0',\n    select_names='None',\n    select_elements='H',\n    select_regexes='None'\n)\n</pre> # create a new folder for this example folder_iso2aniso = path_local / 'run_iso2aniso' folder_iso2aniso.mkdir(exist_ok=True)  # copy files shutil.copy('./input_files/iso2aniso.cif', folder_iso2aniso / 'iso2aniso.cif')  # run command calc2 = qcrboxtools.iso2aniso(     cif_path=path_qcrbox / 'run_iso2aniso' / 'iso2aniso.cif',     cif_dataset='0',     select_names='None',     select_elements='H',     select_regexes='None' ) In\u00a0[\u00a0]: Copied! <pre>print(calc2.status)\ncalc2.wait_while_running(0.2)\nprint(calc2.status)\n</pre> print(calc2.status) calc2.wait_while_running(0.2) print(calc2.status) In\u00a0[\u00a0]: Copied! <pre># create a new folder for this example\nfolder_convergence = path_local / 'run_convergence'\nfolder_convergence.mkdir(exist_ok=True)\n\n# copy files\nshutil.copy('./input_files/difference_test1.cif', folder_convergence / 'difference_test1.cif')\nshutil.copy('./input_files/difference_test2.cif', folder_convergence / 'difference_test2.cif')\n\n# start calculation\ncalc3 = qcrboxtools.check_structure_convergence(\n    cif1_path=path_qcrbox / 'run_convergence' / 'difference_test1.cif',\n    cif2_path=path_qcrbox / 'run_convergence' / 'difference_test2.cif',\n    max_abs_position='0.001',\n    max_position_su='None',\n    max_abs_uij='0.005',\n    max_uij_su='1.0',\n    output_json=path_qcrbox / 'run_convergence' / 'output.json'\n)\n\n# wait for calculation to finish (should be really quick here)\ncalc3.wait_while_running(0.2)\nprint(calc3.status)\n</pre> # create a new folder for this example folder_convergence = path_local / 'run_convergence' folder_convergence.mkdir(exist_ok=True)  # copy files shutil.copy('./input_files/difference_test1.cif', folder_convergence / 'difference_test1.cif') shutil.copy('./input_files/difference_test2.cif', folder_convergence / 'difference_test2.cif')  # start calculation calc3 = qcrboxtools.check_structure_convergence(     cif1_path=path_qcrbox / 'run_convergence' / 'difference_test1.cif',     cif2_path=path_qcrbox / 'run_convergence' / 'difference_test2.cif',     max_abs_position='0.001',     max_position_su='None',     max_abs_uij='0.005',     max_uij_su='1.0',     output_json=path_qcrbox / 'run_convergence' / 'output.json' )  # wait for calculation to finish (should be really quick here) calc3.wait_while_running(0.2) print(calc3.status) In\u00a0[\u00a0]: Copied! <pre>calc4 = qcrboxtools.replace_structure_from_cif(\n    input_cif_path='/mnt/qcrbox/shared_files/replace_test/test.cif',\n    structure_cif_path='/mnt/qcrbox/shared_files/replace_test/80K_P_out.cif'\n)\n</pre> calc4 = qcrboxtools.replace_structure_from_cif(     input_cif_path='/mnt/qcrbox/shared_files/replace_test/test.cif',     structure_cif_path='/mnt/qcrbox/shared_files/replace_test/80K_P_out.cif' ) In\u00a0[\u00a0]: Copied! <pre>print(calc4.status)\ncalc4.wait_while_running(0.2)\nprint(calc4.status)\n</pre> print(calc4.status) calc4.wait_while_running(0.2) print(calc4.status) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/examples/example_qcrboxtools/#run-functions-from-qcrboxtools-from-qcrbox","title":"Run functions from QCrBoxTools from QCrBox\u00b6","text":"<p>QCrBoxTools is a library that is installed in any QCrBox container. At the moment it contains three types of functionality. Firstly, functionality to modify, trim, merge or convert the cif entries if crystallographic information framework (cif) files. Secondly, implementations to automatically run some programs we have added to the QCrBox (which are the \"Robot\" classes.) Finally, functions which are needed in a pipeline workflow of QCrBox. The latter functionality is exposed via the QCrBoxTools container.</p>"},{"location":"tutorials/examples/example_qcrboxtools/#connecting-to-qcrbox","title":"Connecting to QCrBox\u00b6","text":"<p>We can connect to the QCrBox Inventory via python after we have started everything with qcb up. Sometimes the server takes a while so you might need to retry if it initially refuses connection. This should not take more than 30 seconds after your console output says that everything has started.</p>"},{"location":"tutorials/examples/example_qcrboxtools/#converting-a-given-cif-to-the-unified-keywords-used-in-qcrboxtools","title":"Converting a given cif to the unified keywords used in QCrBoxTools\u00b6","text":"<p>QCrBox works with a subsect of cif entries, which are the base cif entries in the current cif dictionaries (as of February 2024). Additionally uncertainties are split into their own entries. Within the individual containers, the unified cif is then converted to whatever input the individual programs need. To convert any cif file into this format we can use the <code>to_unified_cif</code> method of QCrBoxTools. If you prefer to use an outside library instead up spinning up a container, the QCrBoxtools python library also offers this functionality in the <code>cif_file_unify_split</code> function of the <code>qcrboxtools.cif.cif2cif</code> module.</p> <p>Let us copy an example file and do the transformation. Notice that calculations in QCrBox are started asynchronously. We can track the status of the calculation using the QCrBoxCalculation object returned by the command call. The QCrBoxCalculation also has a <code>wait_while_running</code> method that allows us to stop our script until the command has been completed.</p>"},{"location":"tutorials/examples/example_qcrboxtools/#making-atoms-anisotropic","title":"Making atoms anisotropic\u00b6","text":"<p>There is a helper function to make selected atoms anisotropic. Here we can select a dataset, by name or index. The string given in dataset will always be tried as a name of a datablock (in case one of your datablocks is named as a number). If there is no data block of that name, the function will then try to interpret the <code>cif_dataset</code> as an index starting from 0 for the first dataset.</p>"},{"location":"tutorials/examples/example_qcrboxtools/#functions-for-use-within-a-data-processing-pipeline","title":"Functions for use within a data processing pipeline\u00b6","text":""},{"location":"tutorials/examples/example_qcrboxtools/#run-a-convergence-check-between-two-cif-files","title":"Run a convergence check between two cif files\u00b6","text":"<p>Parameters: Setting a value to <code>None</code> will deactivate that test</p> <ul> <li><code>max_abs_position</code> : Maximum difference in atomic positions in Angstrom</li> <li><code>max_position_su</code> : Maximum position difference / position su</li> <li><code>max abs uij</code>: Maximum difference in anisotropic displacement parameters in Ang**2</li> <li><code>max uij su</code>: Maximum Uij difference / Uij su</li> </ul> <p>Output will be written to <code>output_json</code> in json format</p>"},{"location":"tutorials/examples/example_qcrboxtools/#replace-structure-from-cif","title":"Replace structure from cif\u00b6","text":"<p>replaces structure in input_cif_path with atomic structure (atom_site_table) from structure structure_cif_path. Will be extended in the future.</p>"},{"location":"tutorials/examples/example_xharpy/","title":"Interacting with XHARPy","text":"In\u00a0[\u00a0]: Copied! <pre>import shutil\n\nfrom qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper\n</pre> import shutil  from qcrbox_wrapper import QCrBoxWrapper, QCrBoxPathHelper  <p>We create an example folder to try out this functionality.</p> <p>Using the dotenv package makes things more convenient as we can read the environment variables from the .env.dev file in the QCrBox directory. If you want to run with python core packages only, use the <code>__init__</code> method instead by defining the path to the shared directory explicitely in <code>path_to_shared_dir</code> and replacing the next four lines with:</p> <pre>pathhelper = QCrBoxPathHelper(\n    path_to_shared_dir,\n    'examples_xharpy'\n)\n</pre> In\u00a0[\u00a0]: Copied! <pre>pathhelper = QCrBoxPathHelper.from_dotenv(\n    '.env.dev',\n    'examples_xharpy'\n)\n\npath_local = pathhelper.local_path\npath_qcrbox = pathhelper.qcrbox_path\n</pre> pathhelper = QCrBoxPathHelper.from_dotenv(     '.env.dev',     'examples_xharpy' )  path_local = pathhelper.local_path path_qcrbox = pathhelper.qcrbox_path In\u00a0[\u00a0]: Copied! <pre>qcrbox = QCrBoxWrapper('127.0.0.1', 11000)\n</pre> qcrbox = QCrBoxWrapper('127.0.0.1', 11000) In\u00a0[\u00a0]: Copied! <pre>qcrbox.application_dict\n</pre> qcrbox.application_dict In\u00a0[\u00a0]: Copied! <pre>xharpy = qcrbox.application_dict['XHARPy-GPAW']\n</pre> xharpy = qcrbox.application_dict['XHARPy-GPAW'] In\u00a0[\u00a0]: Copied! <pre>help(xharpy)\n</pre> help(xharpy) In\u00a0[\u00a0]: Copied! <pre># create a new folder for this example\nfolder_aff = path_local / 'run_tsc_calc'\nfolder_aff.mkdir(exist_ok=True)\n\n# copy file\nshutil.copy('./input_files/input.cif', folder_aff / 'input.cif')\n\n# start command\ncalc = xharpy.atom_form_fact_gpaw(\n    input_cif_path=path_qcrbox / 'run_tsc_calc' / 'input.cif',\n    output_tsc_path=path_qcrbox / 'run_tsc_calc' / 'affs.tsc',\n    functional='PBE',\n    gridspacing=0.20\n)\n\n# wait for command to finish\ncalc.wait_while_running(1.0)\n</pre> # create a new folder for this example folder_aff = path_local / 'run_tsc_calc' folder_aff.mkdir(exist_ok=True)  # copy file shutil.copy('./input_files/input.cif', folder_aff / 'input.cif')  # start command calc = xharpy.atom_form_fact_gpaw(     input_cif_path=path_qcrbox / 'run_tsc_calc' / 'input.cif',     output_tsc_path=path_qcrbox / 'run_tsc_calc' / 'affs.tsc',     functional='PBE',     gridspacing=0.20 )  # wait for command to finish calc.wait_while_running(1.0) In\u00a0[\u00a0]: Copied! <pre># create a new folder for this example\nfolder_har = path_local / 'run_har'\nfolder_har.mkdir(exist_ok=True)\n\n# copy file\nshutil.copy('./input_files/input.cif', folder_har / 'input.cif')\n\n# start command\ncalc2 = xharpy.ha_refine(\n    input_cif_path=path_qcrbox / 'run_har' / 'input.cif',\n    output_cif_path=path_qcrbox / 'run_har' / 'output.cif',\n    functional='PBE',\n    gridspacing=0.20\n)\n\n# wait for command to finish\nprint(calc2.status)\ncalc2.wait_while_running(1.0)\nprint(calc2.status)\n</pre> # create a new folder for this example folder_har = path_local / 'run_har' folder_har.mkdir(exist_ok=True)  # copy file shutil.copy('./input_files/input.cif', folder_har / 'input.cif')  # start command calc2 = xharpy.ha_refine(     input_cif_path=path_qcrbox / 'run_har' / 'input.cif',     output_cif_path=path_qcrbox / 'run_har' / 'output.cif',     functional='PBE',     gridspacing=0.20 )  # wait for command to finish print(calc2.status) calc2.wait_while_running(1.0) print(calc2.status) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/examples/example_xharpy/#run-functions-from-xharpy-from-qcrbox","title":"Run functions from XHARPy from QCrBox\u00b6","text":"<p>XHARPy is an external library to calculate atomic from factors from periodic PAW DFT calculations availablable on its own on Github. Two functionalities are currently exposed within QCrBox: calculation of atomic form factors and full HAR refinement.</p> <p>The example starts again by using the dotenv package. It makes things more convenient as we can read the environment variables from the .env.dev file in the QCrBox directory. If you want to run with python core packages only, comment out the load_dotenv lines and insert the local and qcrbox pathes manually into the <code>pathhelper</code> using the information in your .env.dev file.</p>"},{"location":"tutorials/examples/example_xharpy/#connecting-to-qcrbox","title":"Connecting to QCrBox\u00b6","text":"<p>We can connect to the QCrBox Inventory via python after we have started everything with qcb up. Sometimes the server takes a while so you might need to retry if it initially refuses connection. This should not take more than 30 seconds after your console output says that everything has started.</p>"},{"location":"tutorials/examples/example_xharpy/#calculating-aspheric-atomic-form-factors-and-writing-them-into-a-tsc-file","title":"Calculating aspheric atomic form factors and writing them into a tsc file\u00b6","text":"<p>A <code>tsc</code> file is the current standard way of exchanging non-spheric atomic form factors. Here we can calculate the tsc for the atoms within our asymmetric unit for the given crystal structure using GPAW. Functionals are any functionals that GPAW can use. A smaller grid spacing means more grid points i.e. a larger basis set in our calculation.</p>"},{"location":"tutorials/examples/example_xharpy/#running-a-hirshfeld-atom-refinement","title":"Running a Hirshfeld Atom Refinement\u00b6","text":"<p>XHARPy can also refine a structure directly. As the XHARPy refinement is slower than that of Olex2 this should probably be seen as an example more than a direct implementation. Functionals are any functionals that GPAW can use. A smaller grid spacing means more grid points i.e. a larger basis set in our calculation.</p>"},{"location":"tutorials/examples/qcrbox_wrapper/","title":"Qcrbox wrapper","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nThis module provides a comprehensive interface for interacting with the QCrBox server,\nenabling the execution of commands, retrieval of application information, and management\nof calculation statuses. It defines classes for wrapping the QCrBox API, representing\napplications, commands, and calculations, alongside a utility class for path management\nwithin QCrBox Docker containers. Additionally, it utilizes namedtuples for structured\nrepresentation of command parameters and calculation statuses.\n\nClasses\n-------\nQCrBoxWrapper : Interface to interact with the QCrBox server.\nQCrBoxApplication : Represents an application within QCrBox.\nQCrBoxCommand : Represents a command for execution on the QCrBox server.\nQCrBoxCalculation : Represents a calculation performed on the QCrBox server.\nQCrBoxPathHelper : Manages file paths within QCrBox Docker containers.\n\nNamedtuples\n-----------\nQCrBoxParameter : Represents a parameter for QCrBoxCommand.\nQCrBoxCalculationStatus : Represents the status of a calculation in QCrBox.\n\"\"\"\n</pre> \"\"\" This module provides a comprehensive interface for interacting with the QCrBox server, enabling the execution of commands, retrieval of application information, and management of calculation statuses. It defines classes for wrapping the QCrBox API, representing applications, commands, and calculations, alongside a utility class for path management within QCrBox Docker containers. Additionally, it utilizes namedtuples for structured representation of command parameters and calculation statuses.  Classes ------- QCrBoxWrapper : Interface to interact with the QCrBox server. QCrBoxApplication : Represents an application within QCrBox. QCrBoxCommand : Represents a command for execution on the QCrBox server. QCrBoxCalculation : Represents a calculation performed on the QCrBox server. QCrBoxPathHelper : Manages file paths within QCrBox Docker containers.  Namedtuples ----------- QCrBoxParameter : Represents a parameter for QCrBoxCommand. QCrBoxCalculationStatus : Represents the status of a calculation in QCrBox. \"\"\" In\u00a0[\u00a0]: Copied! <pre>import json\nimport os\nimport pathlib\nimport textwrap\nimport time\nimport urllib\nimport urllib.request\nimport webbrowser\nfrom collections import namedtuple\nfrom functools import lru_cache\nfrom itertools import count\nfrom typing import Dict, List, Optional, Tuple, Union\n</pre> import json import os import pathlib import textwrap import time import urllib import urllib.request import webbrowser from collections import namedtuple from functools import lru_cache from itertools import count from typing import Dict, List, Optional, Tuple, Union In\u00a0[\u00a0]: Copied! <pre>@lru_cache(maxsize=5)\ndef get_time_cached_app_anwer(server_url: str, ttl_hash: Optional[int] = None) -&gt; Dict[str, str]:\n    \"\"\"\n    Retrieves cached application answers from the QCrBox server.\n\n    This function is memoized to cache responses based on the server URL and a\n    time-to-live (TTL) hash. It is designed to reduce the number of requests\n    made to the server for the same information within a short period.\n\n    Parameters\n    ----------\n    server_url : str\n        The URL of the QCrBox server.\n    ttl_hash : Optional[int]\n        A hash value representing the time-to-live for the cache. This value\n        controls the cache's validity period to prevent outdated information.\n\n    Returns\n    -------\n    Dict[str, str]\n        The response from the QCrBox server, typically a list of application details.\n\n    Note\n    ----\n    The way this function is implemented the cached value is cached within fixed\n    intervals, instead of for a fixed time.\n    \"\"\"\n    del ttl_hash\n    with urllib.request.urlopen(f\"{server_url}/applications/\") as r:\n        answers = json.loads(r.read().decode(\"UTF-8\"))\n    return answers\n</pre> @lru_cache(maxsize=5) def get_time_cached_app_anwer(server_url: str, ttl_hash: Optional[int] = None) -&gt; Dict[str, str]:     \"\"\"     Retrieves cached application answers from the QCrBox server.      This function is memoized to cache responses based on the server URL and a     time-to-live (TTL) hash. It is designed to reduce the number of requests     made to the server for the same information within a short period.      Parameters     ----------     server_url : str         The URL of the QCrBox server.     ttl_hash : Optional[int]         A hash value representing the time-to-live for the cache. This value         controls the cache's validity period to prevent outdated information.      Returns     -------     Dict[str, str]         The response from the QCrBox server, typically a list of application details.      Note     ----     The way this function is implemented the cached value is cached within fixed     intervals, instead of for a fixed time.     \"\"\"     del ttl_hash     with urllib.request.urlopen(f\"{server_url}/applications/\") as r:         answers = json.loads(r.read().decode(\"UTF-8\"))     return answers In\u00a0[\u00a0]: Copied! <pre>def get_ttl_hash(seconds: int = 20) -&gt; int:\n    \"\"\"\n    Generates a hash based on the current time and a specified number of seconds.\n\n    This function divides the current UNIX timestamp by the specified number of\n    seconds and rounds the result to produce a hash. This hash can be used to\n    implement caching mechanisms where cached values expire after a certain duration.\n\n    Parameters\n    ----------\n    seconds : int, optional\n        The number of seconds to divide the current UNIX timestamp by, by default 20.\n\n    Returns\n    -------\n    int\n        The generated hash value.\n    Note\n    ----\n    The way this function is implemented the cached value is cached within fixed\n    intervals, where the rounded seconds value is the sameinstead of for a fixed\n    time.\n    \"\"\"\n    return round(time.time() / seconds)\n</pre> def get_ttl_hash(seconds: int = 20) -&gt; int:     \"\"\"     Generates a hash based on the current time and a specified number of seconds.      This function divides the current UNIX timestamp by the specified number of     seconds and rounds the result to produce a hash. This hash can be used to     implement caching mechanisms where cached values expire after a certain duration.      Parameters     ----------     seconds : int, optional         The number of seconds to divide the current UNIX timestamp by, by default 20.      Returns     -------     int         The generated hash value.     Note     ----     The way this function is implemented the cached value is cached within fixed     intervals, where the rounded seconds value is the sameinstead of for a fixed     time.     \"\"\"     return round(time.time() / seconds) In\u00a0[\u00a0]: Copied! <pre>QCrBoxParameter = namedtuple(\"QCrBoxParameter\", [\"name\", \"dtype\"])\nQCrBoxParameter.__doc__ = \"\"\"\nRepresents a parameter for a QCrBoxCommand in QCrBox.\n\nAttributes\n----------\nname : str\n    Name of the parameter.\ndtype : str\n    Data type of the parameter.\n\"\"\"\n</pre> QCrBoxParameter = namedtuple(\"QCrBoxParameter\", [\"name\", \"dtype\"]) QCrBoxParameter.__doc__ = \"\"\" Represents a parameter for a QCrBoxCommand in QCrBox.  Attributes ---------- name : str     Name of the parameter. dtype : str     Data type of the parameter. \"\"\" In\u00a0[\u00a0]: Copied! <pre>QCrBoxCalculationStatus = namedtuple(\n    \"QCrBoxCalculationStatus\",\n    [\"calculation_id\", \"command_id\", \"started_at\", \"status\", \"status_details\"],\n)\nQCrBoxCalculationStatus.__doc__ = \"\"\"\nRepresents the status of a calculation in QCrBox.\n\nAttributes\n----------\ncalculation_id : int\n    Unique identifier for the calculation.\ncommand_id : int\n    ID of the command that initiated the calculation.\nstarted_at : str\n    Timestamp when the calculation started.\nstatus : str\n    Status of the calculation (e.g., 'running', 'completed').\nstatus_details : dict\n    Detailed status information of the calculation.\n\"\"\"\n</pre> QCrBoxCalculationStatus = namedtuple(     \"QCrBoxCalculationStatus\",     [\"calculation_id\", \"command_id\", \"started_at\", \"status\", \"status_details\"], ) QCrBoxCalculationStatus.__doc__ = \"\"\" Represents the status of a calculation in QCrBox.  Attributes ---------- calculation_id : int     Unique identifier for the calculation. command_id : int     ID of the command that initiated the calculation. started_at : str     Timestamp when the calculation started. status : str     Status of the calculation (e.g., 'running', 'completed'). status_details : dict     Detailed status information of the calculation. \"\"\" In\u00a0[\u00a0]: Copied! <pre>class QCrBoxWrapper:\n    \"\"\"\n    Provides an interface to interact with the QCrBox server.\n\n    Parameters\n    ----------\n    server_addr : str\n        The address/IP of the QCrBox server.\n    server_port : int\n        The port on which the QCrBox server is running.\n    gui_infos : Optional[Dict[str, Dict[str, Union[int, str]]]] = None\n        GUI information for applications, including ports and commands that have a GUI.\n        For each application containing a GUI command, the Application name should be\n        the key, with another dict as the item. This dictionary needs the the entries\n        \"port\" with the port the access the GUI, as well as an entry \"commands\" that\n        containts a list of all the interactive commands.\n\n    Raises\n    ------\n    ConnectionError\n        If the connection to the QCrBox Registry Server fails.\n    \"\"\"\n\n    def __init__(\n        self,\n        server_addr: str,\n        server_port: int,\n        gui_infos: Optional[Dict[str, Dict[str, Union[int, str]]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the QCrBoxWrapper instance.\n\n        Parameters\n        ----------\n        server_addr : str\n            The address/IP of the QCrBox server.\n        server_port : int\n            The port on which the QCrBox server is running.\n        gui_infos : Optional[Dict[str, Dict[str, Union[int, str]]]] = None\n            Dictionary containing the GUI information for applications, including ports\n            and commands that have a GUI. For each application containing a GUI command,\n            the application name should be the key, with another dict as the item. This\n            dictionary needs the the entries \"port\" with the port the access the GUI,\n            as well as an entry \"commands\" that containts a list of all the interactive\n            commands.\n\n        Raises\n        ------\n        ConnectionError\n            If the connection to the QCrBox Registry Server fails.\n        \"\"\"\n        self.server_addr = server_addr\n        self.server_port = server_port\n\n        # TODO Replace with commands reporting the port\n        default_gui_infos = {\n            \"Eval1X\": {\"port\": 12005, \"commands\": [\"interactive\"]},\n            \"Olex2 (Linux)\": {\"port\": 12004, \"commands\": [\"interactive\"]},\n            \"CrystalExplorer\": {\"port\": 12003, \"commands\": [\"interactive\"]},\n        }\n        if gui_infos is None:\n            self.gui_infos = default_gui_infos\n        else:\n            self.gui_infos = gui_infos.update(default_gui_infos)\n\n        with urllib.request.urlopen(f\"{self.server_url}\") as r:\n            answers = json.loads(r.read().decode(\"UTF-8\"))\n\n        if \"QCrBox\" not in answers:\n            print(answers)\n            raise ConnectionError(f\"Cannot connect to QCrBox Registry Server at {self.server_url}\")\n\n    @property\n    def server_url(self) -&gt; str:\n        \"\"\"\n        Constructs the full URL of the QCrBox server.\n\n        Returns\n        -------\n        str\n            The server URL.\n        \"\"\"\n        return f\"http://{self.server_addr}:{self.server_port}\"\n\n    @property\n    def applications(self) -&gt; List[\"QCrBoxApplication\"]:\n        \"\"\"\n        Retrieves a list of applications from the QCrBox server.\n\n        Returns\n        -------\n        List[QCrBoxApplication]\n            A list of QCrBoxApplication namedtuples.\n        \"\"\"\n        answers = get_time_cached_app_anwer(self.server_url, get_ttl_hash())\n        return [\n            QCrBoxApplication(\n                int(ans[\"id\"]),\n                ans[\"name\"],\n                ans[\"version\"],\n                ans[\"description\"],\n                ans[\"url\"],\n                self.commands,\n            )\n            for ans in answers\n        ]\n\n    @property\n    def application_dict(self) -&gt; dict:\n        \"\"\"\n        Constructs a dictionary of applications for easy lookup.\n\n        Returns\n        -------\n        dict\n            A dictionary where keys are application names and values are\n            QCrBoxApplication objects.\n        \"\"\"\n        application_list = self.applications\n        return {application.name: application for application in application_list}\n\n    @property\n    def commands(self) -&gt; List[\"QCrBoxCommand\"]:\n        \"\"\"\n        Retrieves a list of commands from the QCrBox server.\n\n        Returns\n        -------\n        List[QCrBoxCommand]\n            A list of QCrBoxCommand objects.\n        \"\"\"\n        answers = get_time_cached_app_anwer(self.server_url, get_ttl_hash())\n\n        # with urllib.request.urlopen(f\"{self.server_url}/applications/\") as r:\n        #    answers = json.loads(r.read().decode(\"UTF-8\"))\n        app_id2name = {ans[\"id\"]: ans[\"name\"] for ans in answers}\n\n        def to_gui_url(app_id, cmd_name):\n            # TODO replace this with information provided from QCrBox itself.\n            app_name = app_id2name[app_id]\n            if app_name in self.gui_infos and cmd_name in self.gui_infos[app_name][\"commands\"]:\n                port = self.gui_infos[app_name][\"port\"]\n                web_url = f\"http://{self.server_addr}:{port}/vnc.html?path=vnc&amp;autoconnect=true&amp;resize=remote\"\n                return web_url\n            return None\n\n        with urllib.request.urlopen(f\"{self.server_url}/commands/\") as r:\n            answers = json.loads(r.read().decode(\"UTF-8\"))\n\n        prepare_commands = {\n            ans[\"name\"][9:]: QCrBoxCommand(\n                int(ans[\"id\"]),\n                ans[\"name\"],\n                int(ans[\"application_id\"]),\n                [QCrBoxParameter(key, dtype) for key, dtype in ans[\"parameters\"].items()],\n                to_gui_url(ans[\"application_id\"], ans[\"name\"]),\n                self,\n                None,\n                None,\n            )\n            for ans in answers\n            if ans[\"name\"].startswith(\"prepare__\")\n        }\n\n        finalise_commands = {\n            ans[\"name\"][10:]: QCrBoxCommand(\n                int(ans[\"id\"]),\n                ans[\"name\"],\n                int(ans[\"application_id\"]),\n                [QCrBoxParameter(key, dtype) for key, dtype in ans[\"parameters\"].items()],\n                to_gui_url(ans[\"application_id\"], ans[\"name\"]),\n                self,\n                None,\n                None,\n            )\n            for ans in answers\n            if ans[\"name\"].startswith(\"finalise__\")\n        }\n\n        commands = [\n            QCrBoxCommand(\n                int(ans[\"id\"]),\n                ans[\"name\"],\n                int(ans[\"application_id\"]),\n                [QCrBoxParameter(key, dtype) for key, dtype in ans[\"parameters\"].items()],\n                to_gui_url(ans[\"application_id\"], ans[\"name\"]),\n                self,\n                prepare_commands.get(ans[\"name\"], None),\n                finalise_commands.get(ans[\"name\"], None),\n            )\n            for ans in answers\n            if not any([ans[\"name\"].startswith(\"prepare__\"), ans[\"name\"].startswith(\"finalise__\")])\n        ]\n        return commands\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;QCrBoxWrapper(server_addr={self.server_addr}, server_port={self.server_port})&gt;\"\n</pre> class QCrBoxWrapper:     \"\"\"     Provides an interface to interact with the QCrBox server.      Parameters     ----------     server_addr : str         The address/IP of the QCrBox server.     server_port : int         The port on which the QCrBox server is running.     gui_infos : Optional[Dict[str, Dict[str, Union[int, str]]]] = None         GUI information for applications, including ports and commands that have a GUI.         For each application containing a GUI command, the Application name should be         the key, with another dict as the item. This dictionary needs the the entries         \"port\" with the port the access the GUI, as well as an entry \"commands\" that         containts a list of all the interactive commands.      Raises     ------     ConnectionError         If the connection to the QCrBox Registry Server fails.     \"\"\"      def __init__(         self,         server_addr: str,         server_port: int,         gui_infos: Optional[Dict[str, Dict[str, Union[int, str]]]] = None,     ) -&gt; None:         \"\"\"         Initializes the QCrBoxWrapper instance.          Parameters         ----------         server_addr : str             The address/IP of the QCrBox server.         server_port : int             The port on which the QCrBox server is running.         gui_infos : Optional[Dict[str, Dict[str, Union[int, str]]]] = None             Dictionary containing the GUI information for applications, including ports             and commands that have a GUI. For each application containing a GUI command,             the application name should be the key, with another dict as the item. This             dictionary needs the the entries \"port\" with the port the access the GUI,             as well as an entry \"commands\" that containts a list of all the interactive             commands.          Raises         ------         ConnectionError             If the connection to the QCrBox Registry Server fails.         \"\"\"         self.server_addr = server_addr         self.server_port = server_port          # TODO Replace with commands reporting the port         default_gui_infos = {             \"Eval1X\": {\"port\": 12005, \"commands\": [\"interactive\"]},             \"Olex2 (Linux)\": {\"port\": 12004, \"commands\": [\"interactive\"]},             \"CrystalExplorer\": {\"port\": 12003, \"commands\": [\"interactive\"]},         }         if gui_infos is None:             self.gui_infos = default_gui_infos         else:             self.gui_infos = gui_infos.update(default_gui_infos)          with urllib.request.urlopen(f\"{self.server_url}\") as r:             answers = json.loads(r.read().decode(\"UTF-8\"))          if \"QCrBox\" not in answers:             print(answers)             raise ConnectionError(f\"Cannot connect to QCrBox Registry Server at {self.server_url}\")      @property     def server_url(self) -&gt; str:         \"\"\"         Constructs the full URL of the QCrBox server.          Returns         -------         str             The server URL.         \"\"\"         return f\"http://{self.server_addr}:{self.server_port}\"      @property     def applications(self) -&gt; List[\"QCrBoxApplication\"]:         \"\"\"         Retrieves a list of applications from the QCrBox server.          Returns         -------         List[QCrBoxApplication]             A list of QCrBoxApplication namedtuples.         \"\"\"         answers = get_time_cached_app_anwer(self.server_url, get_ttl_hash())         return [             QCrBoxApplication(                 int(ans[\"id\"]),                 ans[\"name\"],                 ans[\"version\"],                 ans[\"description\"],                 ans[\"url\"],                 self.commands,             )             for ans in answers         ]      @property     def application_dict(self) -&gt; dict:         \"\"\"         Constructs a dictionary of applications for easy lookup.          Returns         -------         dict             A dictionary where keys are application names and values are             QCrBoxApplication objects.         \"\"\"         application_list = self.applications         return {application.name: application for application in application_list}      @property     def commands(self) -&gt; List[\"QCrBoxCommand\"]:         \"\"\"         Retrieves a list of commands from the QCrBox server.          Returns         -------         List[QCrBoxCommand]             A list of QCrBoxCommand objects.         \"\"\"         answers = get_time_cached_app_anwer(self.server_url, get_ttl_hash())          # with urllib.request.urlopen(f\"{self.server_url}/applications/\") as r:         #    answers = json.loads(r.read().decode(\"UTF-8\"))         app_id2name = {ans[\"id\"]: ans[\"name\"] for ans in answers}          def to_gui_url(app_id, cmd_name):             # TODO replace this with information provided from QCrBox itself.             app_name = app_id2name[app_id]             if app_name in self.gui_infos and cmd_name in self.gui_infos[app_name][\"commands\"]:                 port = self.gui_infos[app_name][\"port\"]                 web_url = f\"http://{self.server_addr}:{port}/vnc.html?path=vnc&amp;autoconnect=true&amp;resize=remote\"                 return web_url             return None          with urllib.request.urlopen(f\"{self.server_url}/commands/\") as r:             answers = json.loads(r.read().decode(\"UTF-8\"))          prepare_commands = {             ans[\"name\"][9:]: QCrBoxCommand(                 int(ans[\"id\"]),                 ans[\"name\"],                 int(ans[\"application_id\"]),                 [QCrBoxParameter(key, dtype) for key, dtype in ans[\"parameters\"].items()],                 to_gui_url(ans[\"application_id\"], ans[\"name\"]),                 self,                 None,                 None,             )             for ans in answers             if ans[\"name\"].startswith(\"prepare__\")         }          finalise_commands = {             ans[\"name\"][10:]: QCrBoxCommand(                 int(ans[\"id\"]),                 ans[\"name\"],                 int(ans[\"application_id\"]),                 [QCrBoxParameter(key, dtype) for key, dtype in ans[\"parameters\"].items()],                 to_gui_url(ans[\"application_id\"], ans[\"name\"]),                 self,                 None,                 None,             )             for ans in answers             if ans[\"name\"].startswith(\"finalise__\")         }          commands = [             QCrBoxCommand(                 int(ans[\"id\"]),                 ans[\"name\"],                 int(ans[\"application_id\"]),                 [QCrBoxParameter(key, dtype) for key, dtype in ans[\"parameters\"].items()],                 to_gui_url(ans[\"application_id\"], ans[\"name\"]),                 self,                 prepare_commands.get(ans[\"name\"], None),                 finalise_commands.get(ans[\"name\"], None),             )             for ans in answers             if not any([ans[\"name\"].startswith(\"prepare__\"), ans[\"name\"].startswith(\"finalise__\")])         ]         return commands      def __repr__(self) -&gt; str:         return f\"\" In\u00a0[\u00a0]: Copied! <pre>class QCrBoxApplication:\n    \"\"\"\n    Represents an application in QCrBox packaged in its own container.\n\n    Parameters\n    ----------\n    app_id : int\n        Unique identifier for the application.\n    name : str\n        Name of the application.\n    version : str\n        Version of the application.\n    description : str\n        Description of the application.\n    url : str\n        URL for the application documentation or homepage.\n    server_commands : List[QCrBoxCommand]\n        A list of commands available for this application.\n    \"\"\"\n\n    def __init__(\n        self,\n        app_id: int,\n        name: str,\n        version: str,\n        description: str,\n        url: str,\n        server_commands: List[\"QCrBoxCommand\"],\n    ) -&gt; None:\n        \"\"\"\n        Initializes the QCrBoxApplication instance.\n\n        Parameters\n        ----------\n        app_id : int\n            Unique identifier for the application.\n        name : str\n            Name of the application.\n        version : str\n            Version of the application.\n        description : str\n            Description of the application.\n        url : str\n            URL for the application documentation or homepage.\n        server_commands : List[QCrBoxCommand]\n            A list of commands available for this application.\n        \"\"\"\n        self.id = app_id\n        self.name = name\n        self.version = version\n        self.description = description\n        self.url = url\n\n        app_cmds = [cmd for cmd in server_commands if cmd.application_id == self.id]\n        method_strings = []\n        for cmd in app_cmds:\n            parameter_strings = (f\"{par.name}: {par.dtype}\" for par in cmd.parameters)\n            base_indent = \"\\n                    \"\n            all_par_string = base_indent + (\",\" + base_indent).join(parameter_strings) + \"\\n                \"\n            method_strings.append(f\"{cmd.name}({all_par_string})\")\n            setattr(self, cmd.name, cmd)\n\n        linker = \"\\n\\n                \"\n\n        self.__doc__ = textwrap.dedent(\n            f\"\"\"\n            Represents the {self.name} application (v. {self.version}) in QCrBox\n\n            Methods:\n                {linker.join(method_strings)}\n            \"\"\"\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.name}()\"\n</pre> class QCrBoxApplication:     \"\"\"     Represents an application in QCrBox packaged in its own container.      Parameters     ----------     app_id : int         Unique identifier for the application.     name : str         Name of the application.     version : str         Version of the application.     description : str         Description of the application.     url : str         URL for the application documentation or homepage.     server_commands : List[QCrBoxCommand]         A list of commands available for this application.     \"\"\"      def __init__(         self,         app_id: int,         name: str,         version: str,         description: str,         url: str,         server_commands: List[\"QCrBoxCommand\"],     ) -&gt; None:         \"\"\"         Initializes the QCrBoxApplication instance.          Parameters         ----------         app_id : int             Unique identifier for the application.         name : str             Name of the application.         version : str             Version of the application.         description : str             Description of the application.         url : str             URL for the application documentation or homepage.         server_commands : List[QCrBoxCommand]             A list of commands available for this application.         \"\"\"         self.id = app_id         self.name = name         self.version = version         self.description = description         self.url = url          app_cmds = [cmd for cmd in server_commands if cmd.application_id == self.id]         method_strings = []         for cmd in app_cmds:             parameter_strings = (f\"{par.name}: {par.dtype}\" for par in cmd.parameters)             base_indent = \"\\n                    \"             all_par_string = base_indent + (\",\" + base_indent).join(parameter_strings) + \"\\n                \"             method_strings.append(f\"{cmd.name}({all_par_string})\")             setattr(self, cmd.name, cmd)          linker = \"\\n\\n                \"          self.__doc__ = textwrap.dedent(             f\"\"\"             Represents the {self.name} application (v. {self.version}) in QCrBox              Methods:                 {linker.join(method_strings)}             \"\"\"         )      def __repr__(self) -&gt; str:         return f\"{self.name}()\" In\u00a0[\u00a0]: Copied! <pre>class QCrBoxCommand:\n    \"\"\"\n    Represents a command to be executed on the QCrBox server.\n\n    Parameters\n    ----------\n    cmd_id : int\n        Unique identifier for the command.\n    name : str\n        Name of the command.\n    application_id : int\n        ID of the application used by the command.\n    parameters : List[QCrBoxParameter]\n        List of parameters for the command.\n    gui_url : Optional[str]\n        URL for the GUI, if applicable.\n    wrapper_parent : QCrBoxWrapper\n        Parent wrapper object that instantiated the command.\n    \"\"\"\n\n    def __init__(\n        self,\n        cmd_id: int,\n        name: str,\n        application_id: int,\n        parameters: List[QCrBoxParameter],\n        gui_url: str,\n        wrapper_parent: QCrBoxWrapper,\n        prepare_cmd: Optional[\"QCrBoxCommand\"] = None,\n        finalise_cmd: Optional[\"QCrBoxCommand\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the QCrBoxCommand instance.\n\n        Parameters\n        ----------\n        cmd_id : int\n            Unique identifier for the command.\n        name : str\n            Name of the command.\n        application_id : int\n            ID of the application used by the command.\n        parameters : List[QCrBoxParameter]\n            List of parameters for the command.\n        gui_url : Optional[str]\n            URL for the GUI, if applicable.\n        wrapper_parent : QCrBoxWrapper\n            Parent wrapper object that instantiated the command.\n        prepare_cmd : Optional[QCrBoxCommand]\n            Passes an optional command that is executed before\n            the actual command is run.\n        finalise_cmd : Optional[QCrBoxCommand]\n            Passes an optional command that is run after the\n            command itself. Is meant for GUI commands where\n            the execution of this command is done after user\n            input.\n        \"\"\"\n        self.id = cmd_id\n        self.name = name\n        self.application_id = application_id\n        self.parameters = parameters\n        self.wrapper_parent = wrapper_parent\n        self.gui_url = gui_url\n        self._server_url = wrapper_parent.server_url\n        self.prepare_cmd = prepare_cmd\n        self.finalise_cmd = finalise_cmd\n\n    @property\n    def par_name_list(self) -&gt; List[str]:\n        \"\"\"\n        Retrieves the names of the parameters for the command.\n\n        Returns\n        -------\n        List[str]\n            A list containing the names of the parameters.\n        \"\"\"\n        return [par.name for par in self.parameters]\n\n    def __call__(self, *args, **kwargs) -&gt; \"QCrBoxCalculation\":\n        \"\"\"\n        Executes the command on the QCrBox server with the provided arguments.\n\n        Parameters\n        ----------\n        *args\n            Positional arguments for the command parameters.\n        **kwargs\n            Keyword arguments for the command parameters.\n\n        Returns\n        -------\n        QCrBoxCalculation\n            The resulting calculation object from executing the command.\n\n        Raises\n        ------\n        NameError\n            If invalid or duplicate keyword arguments are provided.\n        ConnectionError\n            If the command cannot be successfully sent to the server.\n        \"\"\"\n        arguments = {key: str(val) for key, val in zip(self.par_name_list, args)}\n\n        invalid_args = [arg for arg in kwargs if arg not in self.par_name_list]\n        if len(invalid_args) &gt; 0:\n            raise NameError(f'This method got one or more invalid keywords: {\", \".join(invalid_args)}')\n\n        overbooked_args = [arg for arg in kwargs if arg in arguments]\n\n        if len(overbooked_args) &gt; 0:\n            raise NameError(f'One or more kwargs already set as args: {\", \".join(overbooked_args)}')\n\n        arguments.update({key: str(val) for key, val in kwargs.items()})\n        if self.prepare_cmd is not None:\n            prepare_arguments = {key: val for key, val in arguments.items() if key in self.prepare_cmd.par_name_list}\n\n            self.prepare_cmd(**prepare_arguments)\n\n            if \"input_cif_path\" in prepare_arguments:\n                input_cif_path = pathlib.PurePosixPath(arguments[\"input_cif_path\"])\n                arguments[\"input_cif_path\"] = str(input_cif_path.parent / \"work.cif\")\n\n        data_dict = {\n            \"action\": \"invoke_command\",\n            \"payload\": {\"command_id\": self.id, \"arguments\": arguments},\n        }\n        req = urllib.request.Request(f\"{self._server_url}/invoke_command/\", method=\"POST\")\n        req.add_header(\"Content-Type\", \"application/json\")\n        data = json.dumps(data_dict)\n        data = data.encode(\"UTF-8\")\n        r = urllib.request.urlopen(req, data=data)\n        answer = json.loads(r.read())\n        if not answer[\"status\"] == \"success\":\n            print(answer)\n            raise ConnectionError(\"Command not successfully send\")\n\n        if self.gui_url is not None:\n            webbrowser.open(self.gui_url)\n\n            input(\"Press enter when you have finished your interactive session\")\n            if self.finalise_cmd is not None:\n                finalise_arguments = {\n                    key: val for key, val in arguments.items() if key in self.finalise_cmd.par_name_list\n                }\n                self.finalise_cmd(**finalise_arguments)\n\n        return QCrBoxCalculation(answer[\"payload\"][\"calculation_id\"], self)\n\n    def __repr__(self) -&gt; str:\n        return f\"QCrBoxCommand({self.name})\"\n</pre> class QCrBoxCommand:     \"\"\"     Represents a command to be executed on the QCrBox server.      Parameters     ----------     cmd_id : int         Unique identifier for the command.     name : str         Name of the command.     application_id : int         ID of the application used by the command.     parameters : List[QCrBoxParameter]         List of parameters for the command.     gui_url : Optional[str]         URL for the GUI, if applicable.     wrapper_parent : QCrBoxWrapper         Parent wrapper object that instantiated the command.     \"\"\"      def __init__(         self,         cmd_id: int,         name: str,         application_id: int,         parameters: List[QCrBoxParameter],         gui_url: str,         wrapper_parent: QCrBoxWrapper,         prepare_cmd: Optional[\"QCrBoxCommand\"] = None,         finalise_cmd: Optional[\"QCrBoxCommand\"] = None,     ) -&gt; None:         \"\"\"         Initializes the QCrBoxCommand instance.          Parameters         ----------         cmd_id : int             Unique identifier for the command.         name : str             Name of the command.         application_id : int             ID of the application used by the command.         parameters : List[QCrBoxParameter]             List of parameters for the command.         gui_url : Optional[str]             URL for the GUI, if applicable.         wrapper_parent : QCrBoxWrapper             Parent wrapper object that instantiated the command.         prepare_cmd : Optional[QCrBoxCommand]             Passes an optional command that is executed before             the actual command is run.         finalise_cmd : Optional[QCrBoxCommand]             Passes an optional command that is run after the             command itself. Is meant for GUI commands where             the execution of this command is done after user             input.         \"\"\"         self.id = cmd_id         self.name = name         self.application_id = application_id         self.parameters = parameters         self.wrapper_parent = wrapper_parent         self.gui_url = gui_url         self._server_url = wrapper_parent.server_url         self.prepare_cmd = prepare_cmd         self.finalise_cmd = finalise_cmd      @property     def par_name_list(self) -&gt; List[str]:         \"\"\"         Retrieves the names of the parameters for the command.          Returns         -------         List[str]             A list containing the names of the parameters.         \"\"\"         return [par.name for par in self.parameters]      def __call__(self, *args, **kwargs) -&gt; \"QCrBoxCalculation\":         \"\"\"         Executes the command on the QCrBox server with the provided arguments.          Parameters         ----------         *args             Positional arguments for the command parameters.         **kwargs             Keyword arguments for the command parameters.          Returns         -------         QCrBoxCalculation             The resulting calculation object from executing the command.          Raises         ------         NameError             If invalid or duplicate keyword arguments are provided.         ConnectionError             If the command cannot be successfully sent to the server.         \"\"\"         arguments = {key: str(val) for key, val in zip(self.par_name_list, args)}          invalid_args = [arg for arg in kwargs if arg not in self.par_name_list]         if len(invalid_args) &gt; 0:             raise NameError(f'This method got one or more invalid keywords: {\", \".join(invalid_args)}')          overbooked_args = [arg for arg in kwargs if arg in arguments]          if len(overbooked_args) &gt; 0:             raise NameError(f'One or more kwargs already set as args: {\", \".join(overbooked_args)}')          arguments.update({key: str(val) for key, val in kwargs.items()})         if self.prepare_cmd is not None:             prepare_arguments = {key: val for key, val in arguments.items() if key in self.prepare_cmd.par_name_list}              self.prepare_cmd(**prepare_arguments)              if \"input_cif_path\" in prepare_arguments:                 input_cif_path = pathlib.PurePosixPath(arguments[\"input_cif_path\"])                 arguments[\"input_cif_path\"] = str(input_cif_path.parent / \"work.cif\")          data_dict = {             \"action\": \"invoke_command\",             \"payload\": {\"command_id\": self.id, \"arguments\": arguments},         }         req = urllib.request.Request(f\"{self._server_url}/invoke_command/\", method=\"POST\")         req.add_header(\"Content-Type\", \"application/json\")         data = json.dumps(data_dict)         data = data.encode(\"UTF-8\")         r = urllib.request.urlopen(req, data=data)         answer = json.loads(r.read())         if not answer[\"status\"] == \"success\":             print(answer)             raise ConnectionError(\"Command not successfully send\")          if self.gui_url is not None:             webbrowser.open(self.gui_url)              input(\"Press enter when you have finished your interactive session\")             if self.finalise_cmd is not None:                 finalise_arguments = {                     key: val for key, val in arguments.items() if key in self.finalise_cmd.par_name_list                 }                 self.finalise_cmd(**finalise_arguments)          return QCrBoxCalculation(answer[\"payload\"][\"calculation_id\"], self)      def __repr__(self) -&gt; str:         return f\"QCrBoxCommand({self.name})\" In\u00a0[\u00a0]: Copied! <pre>class QCrBoxCalculation:\n    \"\"\"\n    Represents a calculation performed on the QCrBox server.\n\n    Parameters\n    ----------\n    calc_id : int\n        Unique identifier for the calculation.\n    calculation_parent : QCrBoxCommand\n        Parent command object that instantiated the calculation.\n    \"\"\"\n\n    def __init__(self, calc_id: int, calculation_parent: \"QCrBoxCommand\") -&gt; None:\n        \"\"\"\n        Initializes the QCrBoxCalculation instance.\n\n        Parameters\n        ----------\n        calc_id : int\n            Unique identifier for the calculation.\n        calculation_parent : QCrBoxCommand\n            Parent command object that instantiated the calculation.\n        \"\"\"\n        self.id = calc_id\n        self.calculation_parent = calculation_parent\n        self._server_url = calculation_parent._server_url\n\n    @property\n    def status(self) -&gt; QCrBoxCalculationStatus:\n        \"\"\"\n        Fetches and returns the current status of the calculation from the server.\n\n        Returns\n        -------\n        QCrBoxCalculationStatus\n            A namedtuple containing detailed status information of the calculation.\n        \"\"\"\n        with urllib.request.urlopen(f\"{self._server_url}/calculations/{self.id}\") as r:\n            answers = json.loads(r.read().decode(\"UTF-8\"))\n\n        return QCrBoxCalculationStatus(\n            int(answers[\"id\"]),\n            int(answers[\"command_id\"]),\n            answers[\"started_at\"],\n            answers[\"status_details\"][\"status\"],\n            answers[\"status_details\"],\n        )\n\n    def wait_while_running(self, sleep_time: float) -&gt; None:\n        \"\"\"\n        Periodically checks the calculation's status and blocks until it is no longer 'running'.\n\n        Parameters\n        ----------\n        sleep_time : float\n            The interval, in seconds, between status checks.\n\n        Raises\n        ------\n        RuntimeError\n            If the calculation finishes with a status other than 'completed'.\n        \"\"\"\n        while self.status.status == \"running\":\n            time.sleep(sleep_time)\n        if self.status.status != \"completed\":\n            raise RuntimeError(\n                f\"Reported status is not completed but: {self.status.status}. \"\n                + \"Check status infos or Docker logs for error messages\"\n            )\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;QCrBoxCalculation(id={self.id}, parent_command={self.calculation_parent.name})&gt;\"\n</pre> class QCrBoxCalculation:     \"\"\"     Represents a calculation performed on the QCrBox server.      Parameters     ----------     calc_id : int         Unique identifier for the calculation.     calculation_parent : QCrBoxCommand         Parent command object that instantiated the calculation.     \"\"\"      def __init__(self, calc_id: int, calculation_parent: \"QCrBoxCommand\") -&gt; None:         \"\"\"         Initializes the QCrBoxCalculation instance.          Parameters         ----------         calc_id : int             Unique identifier for the calculation.         calculation_parent : QCrBoxCommand             Parent command object that instantiated the calculation.         \"\"\"         self.id = calc_id         self.calculation_parent = calculation_parent         self._server_url = calculation_parent._server_url      @property     def status(self) -&gt; QCrBoxCalculationStatus:         \"\"\"         Fetches and returns the current status of the calculation from the server.          Returns         -------         QCrBoxCalculationStatus             A namedtuple containing detailed status information of the calculation.         \"\"\"         with urllib.request.urlopen(f\"{self._server_url}/calculations/{self.id}\") as r:             answers = json.loads(r.read().decode(\"UTF-8\"))          return QCrBoxCalculationStatus(             int(answers[\"id\"]),             int(answers[\"command_id\"]),             answers[\"started_at\"],             answers[\"status_details\"][\"status\"],             answers[\"status_details\"],         )      def wait_while_running(self, sleep_time: float) -&gt; None:         \"\"\"         Periodically checks the calculation's status and blocks until it is no longer 'running'.          Parameters         ----------         sleep_time : float             The interval, in seconds, between status checks.          Raises         ------         RuntimeError             If the calculation finishes with a status other than 'completed'.         \"\"\"         while self.status.status == \"running\":             time.sleep(sleep_time)         if self.status.status != \"completed\":             raise RuntimeError(                 f\"Reported status is not completed but: {self.status.status}. \"                 + \"Check status infos or Docker logs for error messages\"             )      def __repr__(self) -&gt; str:         return f\"\" In\u00a0[\u00a0]: Copied! <pre>class QCrBoxPathHelper:\n    \"\"\"\n    A helper class for managing file paths within QCrBox Docker containers.\n\n    This class provides methods to convert a path to both local and QCrBox-specific\n    file system paths.\n\n    Attributes\n    ----------\n    local_path : pathlib.Path\n        The base path in the local file system.\n    qcrbox_path : pathlib.Path\n        The base path in the QCrBox file system, defaults to '/mnt/qcrbox/shared_files'.\n\n    Methods\n    -------\n    path_to_local(path: pathlib.Path) -&gt; pathlib.Path\n        Converts a given path to its equivalent in the local file system.\n    path_to_qcrbox(path: pathlib.Path) -&gt; str\n        Converts a given path to its equivalent in the QCrBox file system, returned\n        as a POSIX-style string path.\n    path_to_pair(path: pathlib.Path) -&gt; tuple\n        Returns a tuple of the given path's local and QCrBox equivalents.\n    \"\"\"\n\n    step_counter = count()\n\n    def __init__(\n        self,\n        local_path: pathlib.Path,\n        qcrbox_path: pathlib.PurePosixPath = pathlib.PurePosixPath(\"/mnt/qcrbox/shared_files\"),\n        base_dir: Optional[pathlib.Path] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the QCrBoxPathHelper instance.\n\n        Parameters\n        ----------\n        local_path : pathlib.Path\n            The base path in the local file system.\n        qcrbox_path : pathlib.PurePosixPath, optional\n            The base path in the QCrBox file system (default is '/mnt/qcrbox/shared_files').\n        base_dir : pathlib.Path, optional\n            A subdirectory within both the local and QCrBox base paths for scoped path\n            management. Defaults to None, in which case the base paths are used directly.\n        \"\"\"\n        if str(local_path).startswith(\"\\\\wsl$\\\\\"):\n            local_path = \"\\\\\" + str(local_path)\n        if base_dir is None:\n            self.local_path = pathlib.Path(local_path)\n            self.qcrbox_path = pathlib.PurePosixPath(qcrbox_path)\n        else:\n            self.local_path = pathlib.Path(local_path) / base_dir\n            self.qcrbox_path = pathlib.PurePosixPath(qcrbox_path) / base_dir\n        self.local_path.mkdir(exist_ok=True)\n\n    @classmethod\n    def from_dotenv(cls, dotenv_name: str, base_dir: Optional[pathlib.Path] = None) -&gt; \"QCrBoxPathHelper\":\n        \"\"\"\n        Creates an instance of QCrBoxPathHelper from environment variables defined in a .env file.\n\n        This class method reads the specified .env file to extract the base paths for the local and\n        QCrBox file systems. It then initializes and returns a new instance of QCrBoxPathHelper using\n        these paths.\n        Parameters\n        ----------\n        dotenv_name : str\n            The name of the .env file to be loaded.\n        base_dir : pathlib.Path, optional\n            A subdirectory within both the local and QCrBox base paths for scoped path management.\n            Defaults to None, in which case the base paths provided in the .env file are used directly.\n\n        Returns\n        -------\n        QCrBoxPathHelper\n            An instance of QCrBoxPathHelper initialized with the paths read from the .env file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the .env file specified by `dotenv_name` cannot be found or the required environment\n            variables are not set.\n        \"\"\"\n        import dotenv\n\n        dotenv_path = pathlib.Path(dotenv.find_dotenv(dotenv_name))\n\n        if not dotenv.load_dotenv(dotenv_path):\n            raise FileNotFoundError(\n                \".dot.env file could not be loaded. Create the pathhelper from the\"\n                + \"__init__ method by using \\n\"\n                + \"pathhelper = QCrBoxPathhelper(\\n\"\n                + \"    local_path=&lt;local_path_on_disc&gt;\\n\"\n                + f\"    base_dir={base_dir}\\n\"\n                + \")\"\n            )\n\n        shared_files_path = pathlib.Path(os.environ[\"QCRBOX_SHARED_FILES_DIR_HOST_PATH\"])\n        if str(shared_files_path).startswith(\"\\\\wsl\"):\n            shared_files_path = pathlib.Path(\"\\\\\" + str(shared_files_path))\n        elif not shared_files_path.is_absolute():\n            shared_files_path = dotenv_path.parent / shared_files_path\n\n        return cls(shared_files_path, os.environ[\"QCRBOX_SHARED_FILES_DIR_CONTAINER_PATH\"], base_dir)\n\n    def path_to_local(self, path: pathlib.Path) -&gt; pathlib.Path:\n        \"\"\"\n        Converts a given path to its equivalent in the local file system.\n\n        Parameters\n        ----------\n        path : pathlib.Path\n            The path to be converted, relative to the QCrBox base path.\n\n        Returns\n        -------\n        pathlib.Path\n            The equivalent path in the local file system.\n        \"\"\"\n        return self.local_path / path\n\n    def path_to_qcrbox(self, path: pathlib.Path) -&gt; str:\n        \"\"\"\n        Converts a given path to its equivalent in the QCrBox file system and\n        returns it as a POSIX-style string path.\n\n        Parameters\n        ----------\n        path : pathlib.Path\n            The path to be converted, relative to the local base path.\n\n        Returns\n        -------\n        str\n            The equivalent path in the QCrBox file system as a POSIX-style string.\n        \"\"\"\n        new_path = self.qcrbox_path / path\n        return pathlib.PurePosixPath(new_path)\n\n    def path_to_pair(self, path: pathlib.Path) -&gt; tuple:\n        \"\"\"\n        Returns a tuple containing the given path's equivalents in both the local\n        and QCrBox file systems.\n\n        Parameters\n        ----------\n        path : pathlib.Path\n            The path to be converted.\n\n        Returns\n        -------\n        tuple\n            A tuple of pathlib.Path and str, representing the local and QCrBox\n            file system paths respectively.\n        \"\"\"\n        return self.path_to_local(path), self.path_to_qcrbox(path)\n\n    def create_next_step_folder(self) -&gt; Tuple[pathlib.Path, str]:\n        \"\"\"\n        Creates a new folder for the next step in a sequence within the local file system\n        and returns its path equivalents in both the local and QCrBox file systems.\n\n        This method automatically increments an internal counter to keep track of the\n        \"step\" folders (e.g., \"step_1\", \"step_2\", etc.). Each call to this method results\n        in the creation of a new folder with the next step number in the local file system\n        and returns both the local system path and the QCrBox file system path as a POSIX-style\n        string.\n\n        Returns\n        -------\n        Tuple[pathlib.Path, str]\n            A tuple containing the newly created folder's path in the local file system\n            (as a pathlib.Path object) and its equivalent in the QCrBox file system\n            (as a POSIX-style string path).\n        \"\"\"\n        next_folder = f\"step_{next(self.step_counter)}\"\n        self.path_to_local(next_folder).mkdir(exist_ok=True)\n        return self.path_to_pair(next_folder)\n</pre> class QCrBoxPathHelper:     \"\"\"     A helper class for managing file paths within QCrBox Docker containers.      This class provides methods to convert a path to both local and QCrBox-specific     file system paths.      Attributes     ----------     local_path : pathlib.Path         The base path in the local file system.     qcrbox_path : pathlib.Path         The base path in the QCrBox file system, defaults to '/mnt/qcrbox/shared_files'.      Methods     -------     path_to_local(path: pathlib.Path) -&gt; pathlib.Path         Converts a given path to its equivalent in the local file system.     path_to_qcrbox(path: pathlib.Path) -&gt; str         Converts a given path to its equivalent in the QCrBox file system, returned         as a POSIX-style string path.     path_to_pair(path: pathlib.Path) -&gt; tuple         Returns a tuple of the given path's local and QCrBox equivalents.     \"\"\"      step_counter = count()      def __init__(         self,         local_path: pathlib.Path,         qcrbox_path: pathlib.PurePosixPath = pathlib.PurePosixPath(\"/mnt/qcrbox/shared_files\"),         base_dir: Optional[pathlib.Path] = None,     ) -&gt; None:         \"\"\"         Initializes the QCrBoxPathHelper instance.          Parameters         ----------         local_path : pathlib.Path             The base path in the local file system.         qcrbox_path : pathlib.PurePosixPath, optional             The base path in the QCrBox file system (default is '/mnt/qcrbox/shared_files').         base_dir : pathlib.Path, optional             A subdirectory within both the local and QCrBox base paths for scoped path             management. Defaults to None, in which case the base paths are used directly.         \"\"\"         if str(local_path).startswith(\"\\\\wsl$\\\\\"):             local_path = \"\\\\\" + str(local_path)         if base_dir is None:             self.local_path = pathlib.Path(local_path)             self.qcrbox_path = pathlib.PurePosixPath(qcrbox_path)         else:             self.local_path = pathlib.Path(local_path) / base_dir             self.qcrbox_path = pathlib.PurePosixPath(qcrbox_path) / base_dir         self.local_path.mkdir(exist_ok=True)      @classmethod     def from_dotenv(cls, dotenv_name: str, base_dir: Optional[pathlib.Path] = None) -&gt; \"QCrBoxPathHelper\":         \"\"\"         Creates an instance of QCrBoxPathHelper from environment variables defined in a .env file.          This class method reads the specified .env file to extract the base paths for the local and         QCrBox file systems. It then initializes and returns a new instance of QCrBoxPathHelper using         these paths.         Parameters         ----------         dotenv_name : str             The name of the .env file to be loaded.         base_dir : pathlib.Path, optional             A subdirectory within both the local and QCrBox base paths for scoped path management.             Defaults to None, in which case the base paths provided in the .env file are used directly.          Returns         -------         QCrBoxPathHelper             An instance of QCrBoxPathHelper initialized with the paths read from the .env file.          Raises         ------         FileNotFoundError             If the .env file specified by `dotenv_name` cannot be found or the required environment             variables are not set.         \"\"\"         import dotenv          dotenv_path = pathlib.Path(dotenv.find_dotenv(dotenv_name))          if not dotenv.load_dotenv(dotenv_path):             raise FileNotFoundError(                 \".dot.env file could not be loaded. Create the pathhelper from the\"                 + \"__init__ method by using \\n\"                 + \"pathhelper = QCrBoxPathhelper(\\n\"                 + \"    local_path=\\n\"                 + f\"    base_dir={base_dir}\\n\"                 + \")\"             )          shared_files_path = pathlib.Path(os.environ[\"QCRBOX_SHARED_FILES_DIR_HOST_PATH\"])         if str(shared_files_path).startswith(\"\\\\wsl\"):             shared_files_path = pathlib.Path(\"\\\\\" + str(shared_files_path))         elif not shared_files_path.is_absolute():             shared_files_path = dotenv_path.parent / shared_files_path          return cls(shared_files_path, os.environ[\"QCRBOX_SHARED_FILES_DIR_CONTAINER_PATH\"], base_dir)      def path_to_local(self, path: pathlib.Path) -&gt; pathlib.Path:         \"\"\"         Converts a given path to its equivalent in the local file system.          Parameters         ----------         path : pathlib.Path             The path to be converted, relative to the QCrBox base path.          Returns         -------         pathlib.Path             The equivalent path in the local file system.         \"\"\"         return self.local_path / path      def path_to_qcrbox(self, path: pathlib.Path) -&gt; str:         \"\"\"         Converts a given path to its equivalent in the QCrBox file system and         returns it as a POSIX-style string path.          Parameters         ----------         path : pathlib.Path             The path to be converted, relative to the local base path.          Returns         -------         str             The equivalent path in the QCrBox file system as a POSIX-style string.         \"\"\"         new_path = self.qcrbox_path / path         return pathlib.PurePosixPath(new_path)      def path_to_pair(self, path: pathlib.Path) -&gt; tuple:         \"\"\"         Returns a tuple containing the given path's equivalents in both the local         and QCrBox file systems.          Parameters         ----------         path : pathlib.Path             The path to be converted.          Returns         -------         tuple             A tuple of pathlib.Path and str, representing the local and QCrBox             file system paths respectively.         \"\"\"         return self.path_to_local(path), self.path_to_qcrbox(path)      def create_next_step_folder(self) -&gt; Tuple[pathlib.Path, str]:         \"\"\"         Creates a new folder for the next step in a sequence within the local file system         and returns its path equivalents in both the local and QCrBox file systems.          This method automatically increments an internal counter to keep track of the         \"step\" folders (e.g., \"step_1\", \"step_2\", etc.). Each call to this method results         in the creation of a new folder with the next step number in the local file system         and returns both the local system path and the QCrBox file system path as a POSIX-style         string.          Returns         -------         Tuple[pathlib.Path, str]             A tuple containing the newly created folder's path in the local file system             (as a pathlib.Path object) and its equivalent in the QCrBox file system             (as a POSIX-style string path).         \"\"\"         next_folder = f\"step_{next(self.step_counter)}\"         self.path_to_local(next_folder).mkdir(exist_ok=True)         return self.path_to_pair(next_folder)"}]}